{"meta":{"title":"Kerr&Ann","subtitle":null,"description":"长路漫漫任我闯↗↗","author":"Kerr","url":""},"pages":[{"title":"about","date":"2020-07-10T12:31:42.585Z","updated":"2020-07-10T12:31:42.585Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2020-09-28T13:29:29.659Z","updated":"2020-07-10T12:14:27.113Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"books","date":"2020-10-02T08:19:25.000Z","updated":"2020-10-02T08:25:49.327Z","comments":false,"path":"books/index.html","permalink":"/books/index.html","excerpt":"","text":"","keywords":"书单"},{"title":"categories","date":"2020-10-02T06:59:49.000Z","updated":"2020-10-02T07:02:11.808Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-09-28T13:30:09.643Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-10-02T08:14:20.285Z","updated":"2020-10-02T08:14:20.285Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"pictures","date":"2020-10-02T08:22:04.000Z","updated":"2020-10-02T08:41:56.578Z","comments":false,"path":"pictures/index.html","permalink":"/pictures/index.html","excerpt":"","text":"","keywords":"美图"},{"title":"tags","date":"2020-10-02T06:51:44.000Z","updated":"2020-10-02T07:03:51.725Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-02T06:51:44.000Z","updated":"2020-10-02T07:04:05.990Z","comments":true,"path":"tags/index-1.html","permalink":"/tags/index-1.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-10-02T07:24:57.237Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-10T12:15:37.778Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"","slug":"Spring配置过程","date":"2020-10-29T13:35:26.305Z","updated":"2020-10-29T13:37:46.144Z","comments":true,"path":"2020/10/29/Spring配置过程/","link":"","permalink":"/2020/10/29/Spring配置过程/","excerpt":"","text":"Spring5.2.0spring中文文档https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans1、创建spring工程 具体如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kerr&lt;/groupId&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;spring-01-ioc1&lt;/module&gt; &lt;module&gt;spring-02-hellospring&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2. 创建与配置spring子模块（module） 因为spring子工程继承了初始项目project的pom，因此不需要进一步配置子工程的pom，只需要建立spring相应的工程文件即可： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kerr&lt;/groupId&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;spring-01-ioc1&lt;/module&gt; &lt;module&gt;spring-02-hellospring&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; spring工程实践—— 对应代码： // Hello.java package com.kerr.pojo; public class Hello { private String str; @Override public String toString() { return &quot;Hello{&quot; + &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; + &#39;}&#39;; } public void setStr(String str) { this.str = str; } public String getStr() { return str; } } &lt;!--bean.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 使用spring来创建对象，在spring这些都称为Bean Java写法： 类型 变量名 = new 类型； Hello hello = new Hello(); spring内部： bean = 对象 new Hello(); id = 变量名 class = 全路径（要new的对象） property 相当于给对象的属性设置一个值！ --&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kerr.pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; // MyTest.java import com.kerr.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTset { public static void main(String[] args) { // 获取spring的上下文对象：必写语句 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 我们的对象现在都在spring中管理了，要使用直接去里面取出来就行 Hello hello =(Hello) context.getBean(&quot;hello&quot;); System.out.println(hello.toString()); } } 值得一提的是，spring创建实例对象的方法是通过控制set方法来创建的，这是IOC的原理。 MyTest.java文件中，ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);说明ClassPathXmlApplicationContext与ApplicationContext有着千丝万缕的关系。下面通过源码的方式获取这些继承和实现关系。 可见，从ClassPathXmlApplicationContext到ApplicationContext总共6层关系，前5层是都是继承，最后是实现接口。（此时此刻我又想起了那句经典：你看到的我在第二层，而你把我想成了第一层，实际上我在第五层~~）","categories":[],"tags":[],"keywords":[]},{"title":"从URL到页面解析从URL到页面解析","slug":"从输入URL到页面解析完成的过程","date":"2020-10-28T14:54:05.000Z","updated":"2020-10-28T14:56:37.745Z","comments":true,"path":"2020/10/28/从输入URL到页面解析完成的过程/","link":"","permalink":"/2020/10/28/从输入URL到页面解析完成的过程/","excerpt":"","text":"过程概述js html是基于http在浏览器和服务器之间进行传输（是响应的第四部分的字符串）1.http协议基于TCP/IP协议过程：浏览器输入域名-&gt;浏览器查询dns是否有缓存-&gt;DNS查询到域名-&gt;TCP/IP链接（三次握手）-&gt;建立连接-&gt;浏览器发出请求-&gt;服务器响应（1.2.3.4）-&gt;浏览器会先获得响应头然后在获得相应体（因为响应体有时候会很大）. *1、浏览器地址栏输入url* *2、浏览器会先查看浏览器缓存*--*系统缓存*--*路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步* *3、域名解析（DNS）获取相应的ip* *4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手* *5、握手成功，浏览器向服务器发送http请求，请求数据包* *6、服务器请求数据，将数据返回到浏览器* *7、浏览器接收响应，读取页面内容，解析html源码，生成DOm树* *8、解析css样式、浏览器渲染，js交互绑定多个域名，数量不限* 三次握手知道了服务器的 IP 地址，下面便开始与服务器建立连接了。 通俗地讲，通信连接的建立需要经历以下三个过程： 主机向服务器发送一个建立连接的请求（您好，我想认识您）； 服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。 *补充说明 TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。 网页请求与显示当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ； 四次挥手主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； *补充说明 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"页面解析过程","slug":"页面解析过程","permalink":"/tags/页面解析过程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mybatis的“的增删改查","slug":"Mybatis02","date":"2020-10-23T13:58:00.000Z","updated":"2020-10-23T14:01:52.808Z","comments":true,"path":"2020/10/23/Mybatis02/","link":"","permalink":"/2020/10/23/Mybatis02/","excerpt":"","text":"namespace 将上面案例中的UserMapper接口改名为 UserDao； 将UserMapper.xml中的namespace改为为UserDao的路径 . 再次测试 结论： 配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！ select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType 需求：根据id查询用户 1、在UserMapper中添加对应方法 public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id); } 2、在UserMapper.xml中添加Select语句 &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; 3、测试类中测试 @Test public void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 课堂练习：根据 密码 和 名字 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 //通过密码和名字查询用户 User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd); /* &lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; */ 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map &lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;username&quot;,&quot;小明&quot;); map.put(&quot;pwd&quot;,&quot;123456&quot;); User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 insert 我们一般使用insert标签进行插入操作，它的配置和select标签差不多！ 需求：给数据库增加一个用户 1、在UserMapper接口中添加对应的方法 //添加一个用户 int addUser(User user); 2、在UserMapper.xml中添加insert语句 &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; 3、测试 @Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;); int i = mapper.addUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } 注意点：增、删、改操作需要提交事务！ update 我们一般使用update标签进行更新操作，它的配置和select标签差不多！ 需求：修改用户的信息 1、同理，编写接口方法 //修改一个用户 int updateUser(User user); 2、编写对应的配置文件SQL &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update user set name=#{name},pwd=#{pwd} where id = #{id} &lt;/update&gt; 3、测试 @Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); user.setPwd(&quot;asdfgh&quot;); int i = mapper.updateUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } delete 我们一般使用delete标签进行删除操作，它的配置和select标签差不多！ 需求：根据id删除一个用户 1、同理，编写接口方法 //根据id删除用户 int deleteUser(int id); 2、编写对应的配置文件SQL &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #{id} &lt;/delete&gt; 3、测试 @Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(5); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } 小结： 所有的增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"/tags/Mybatis框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mybatis01","slug":"Mybatis01","date":"2020-10-23T13:50:44.000Z","updated":"2020-10-26T07:44:52.710Z","comments":true,"path":"2020/10/23/Mybatis01/","link":"","permalink":"/2020/10/23/Mybatis01/","excerpt":"","text":"Mybatis创建和初始化流程​```flow st=&gt;start: 打开idea op1=&gt;operation: 1.创建maven项目，删除src目录 op2=&gt;operation: 2.连接数据库 op3=&gt;operation: 3.导入jar包（mysql、mybatis） op4=&gt;operation: 4.创建Mybatis工具类（工具类需要一个配置文件，去resources里写一个配置文件mybatis-config.xml），获取sqlSessionFactory工厂，得到sqlSession op5=&gt;operation: 5.编辑配置文件mybatis-config.xml，环境准备 op6=&gt;operation: 6.写User实体类和UserDao接口 op7=&gt;operation: 6.UserMapper.xml代替原来的UserDao实现类 op8=&gt;operation: 6.测试：获得sqlSession对象，然后调用getMapper方法执行sql获得结果集 e=&gt;end st(bottom)-&gt;op1(bottom)-&gt;op2(bottom)-&gt;op3(bottom)-&gt;op4(bottom)-&gt;op5(bottom)-&gt;op6(bottom)-&gt;op7(bottom)-&gt;op8(bottom)-&gt;e ​ &gt; 环境说明： - jdk 8 + - MySQL 5.7.19 - maven-3.6.1 - IDEA 学习前需要掌握： - JDBC - MySQL - Java 基础 - Maven - Junit &gt; 什么是MyBatis - MyBatis 是一款优秀的**持久层框架** - MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 - MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 - MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 - 2013年11月迁移到**Github** . - Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html - GitHub : https://github.com/mybatis/mybatis-3 &gt; 持久化 **持久化是将程序数据在持久状态和瞬时状态间转换的机制。** - 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 - JDBC就是一种持久化机制。文件IO也是一种持久化机制。 - 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 **为什么需要持久化服务呢？那是由于内存本身的缺陷引起的** - 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 - 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 &gt; 持久层 **什么是持久层？** - 完成持久化工作的代码块 . ----&gt; dao层 【DAO (Data Access Object) 数据访问对象】 - 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种**关系数据库**来完成。 - 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. - 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 &gt; 为什么需要Mybatis - Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . - 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等... , 通过框架可以减少重复代码,提高开发效率 . - MyBatis 是一个半自动化的**ORM框架 (Object Relationship Mapping) --&gt;对象关系映射** - 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！**技术没有高低之分，只有使用这个技术的人有高低之别** - MyBatis的优点 - - 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 - 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 - 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 - 提供xml标签，支持编写动态sql。 - ....... - 最重要的一点，使用的人多！公司需要！ MyBatis第一个程序 **思路流程：搭建环境--&gt;导入Mybatis---&gt;编写代码---&gt;测试** &gt; 代码演示 1、搭建实验数据库 ```sql CREATE DATABASE `mybatis`; USE `mybatis`; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;); 2、导入MyBatis相关 jar 包 GitHub上找 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; 3、编写MyBatis核心配置文件 查看帮助文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4、编写MyBatis工具类 查看帮助文档 import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //获取SqlSession连接 public static SqlSession getSession(){ return sqlSessionFactory.openSession(); } } 5、创建实体类 public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString() } 6、编写Mapper接口类 import com.kuang.pojo.User; import java.util.List; public interface UserMapper { List&lt;User&gt; selectUser(); } 7、编写Mapper.xml配置文件 namespace 十分重要，不能写错！ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 8、编写测试类 Junit 包测试 public class MyTest { @Test public void selectUser() { SqlSession session = MybatisUtils.getSession(); //方法一: //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;); //方法二: UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); } } 9、运行测试，成功的查询出来的我们的数据，ok！ 问题说明 可能出现问题说明：Maven静态资源过滤问题 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"/tags/Mybatis框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"招商金科一面总结","slug":"招商金科一面总结","date":"2020-10-21T08:25:12.000Z","updated":"2020-10-21T08:25:28.654Z","comments":true,"path":"2020/10/21/招商金科一面总结/","link":"","permalink":"/2020/10/21/招商金科一面总结/","excerpt":"","text":"招商金科一面1. 从浏览器输入url到客户端响应的过程2. Spring的注解如何调用的方法3. ArrayList动态扩容机制4. 反射能用来干嘛5. 12306抢票怎么用户实现能抢到又能性能高6. 线程池是怎么实现复用的7. SQL实现多表查询怎么优化8. 怎么理解树的度和阶9. 了解哪些协议？TCP/UDP/HTTP/HTTPS，tcp协议的滑动窗口是用来干嘛的，怎么实现的10. 对检测冲突的协议有了解吗11.对前端（Vue、jQuery）的了解","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"面试","slug":"面试","permalink":"/tags/面试/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"项目一：旅游网站功能实现思路","slug":"项目一：旅游网站功能实现思路","date":"2020-10-20T13:13:28.000Z","updated":"2020-10-20T13:31:16.740Z","comments":true,"path":"2020/10/20/项目一：旅游网站功能实现思路/","link":"","permalink":"/2020/10/20/项目一：旅游网站功能实现思路/","excerpt":"","text":"1. 技术选型1.1 Web层a) Servlet：前端控制器 b) html：视图 c) Filter：过滤器 d) BeanUtils：数据封装 e) Jackson：json序列化工具 1.2 Service层f) Javamail：java发送邮件工具 g) Redis：nosql内存数据库 h) Jedis：java的redis客户端 1.3 Dao层i) Mysql：数据库 j) Druid：数据库连接池 k) JdbcTemplate：jdbc的工具 2. 注册功能的实现思路 3. 登录功能 4. 退出功能 什么叫做登录了？session中有user对象。 实现步骤： 访问servlet，将session销毁 跳转到登录页面 5. 优化Servlet减少Servlet的数量，现在是一个功能一个Servlet，将其优化为一个模块一个Servlet，相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。 6.分类数据展示6.1 分类数据展示（初级） 6.2 对分类数据进行缓存优化分析发现，分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，而且分类的数据不会经常产生变化，所有可以使用redis来缓存这个数据。 7. 根据id查询不同类别的旅游线路数据 8. 旅游线路名称查询9. 旅游线路的详情展示 10. 旅游线路收藏功能 11. 点击按钮收藏线路","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发，项目","slug":"JavaEE开发，项目","permalink":"/tags/JavaEE开发，项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"idea&VS_Code&Shell&Linux命令","slug":"idea&VS_Code&Shell&Linux命令","date":"2020-10-13T12:29:13.000Z","updated":"2020-10-13T12:34:26.878Z","comments":true,"path":"2020/10/13/idea&VS_Code&Shell&Linux命令/","link":"","permalink":"/2020/10/13/idea&VS_Code&Shell&Linux命令/","excerpt":"","text":"idea1. 快速生成变量： Ctrl + Alt + V或者.var 2. 格式化代码： Ctrl + Alt + L 3. try catch异常处理&amp;导包 Alt + Enter 4. 注释： Ctrl + / 单行 Ctrl + shift + / 多行 5. iter迭代器 键入iter 6. foreach（增强for） 数组或者集合名.for 7. 复制上一行内容到下一行 Ctrl + D 8. 多行操作 Alt + 鼠标左键 9. 任意移动一行（也可选中多行进行操作） Shift + Alt + 上/下键 10. 参数提示 Ctrl + P 11. 选中多行代码try...catch 选中+Ctrl+alt+t 12. 向上插入新的一行并且将光标移动到行首 Ctrl+Alt+Enter 13. 向下插入新的一行并且将光标移动到行首 Shift+Enter 14. 快速从接口到实现类 Ctrl+Alt+左键 VS code1. 内嵌实时渲染浏览器 Ctrl + Shift + V 2. 命令面部 Ctrl + Shift + P 3. 多行操作 Alt + Shift + 鼠标左键 相对路径： ./ : 代表当前目录 ../: 代表上一级目录 DOS命令netstat -ano：查看端口号 (ps：PID是进程ID) Linux（CentOS）命令1. ipconfig : 查询ip 2. ll : 列出当前目录详细列表 （后加 -a为显示隐藏文件） 3. ls : 列出当前目录文件（夹）（后加 -a为显示隐藏文件） 4. mkdir : 创建目录 5. rmdir : 删除目录 6. cd : 进入目录","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"/tags/快捷键/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SpringBoot重要笔记","slug":"SpringBoot重要笔记","date":"2020-10-06T00:53:17.000Z","updated":"2020-10-07T15:12:26.600Z","comments":true,"path":"2020/10/06/SpringBoot重要笔记/","link":"","permalink":"/2020/10/06/SpringBoot重要笔记/","excerpt":"","text":"1. 创建SpringBoot项目3种方法： 官方渠道：使用Spring Initializr在线创建并导入idea地址：http://start.spring.io/ 基于idea集成的Spring Initializr（脚手架工具） 基于idea创建maven项目并向pom文件中添加配置、依赖和 插件，使之成文标准SB项目的配置文件结构。一般情况下需要添加的配置有： 2. 启动类 Spring Boot 的启动类的作用是启动Spring Boot 项目，是基于Main 方法来运行的。注意：启动类在启动时会做注解扫描(@Controller、@Service、@Repository……)，扫描位置为同包或者子包下的注解，所以启动类的位置应放于包的根下。 创建启动类一般命名为“项目名+Application ”，然后添加main方法： 注意2点： 添加@SpringBootApplication注解； 在main方法中调用SpringApplication类下的静态方法run， SpringApplication.run(SpringBootDemo1Application.class, args); 有2个参数，分别为“启动类名”和“args”。 3. 启动器 Spring Boot 将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景，在jar 包管理上非常方便，最终实现一站式开发。 4. 配置文件 Spring Boot 提供一个名称为application 的全局配置文件，支持两种格式properteis 格式与YAML 格式。 4.1 Properties格式配置Tomcat监听端口 在resources下（创建）打开application.properties文件，k-v是server.port = 8888，具体如下： 此外，数据源配置，数据库链接信息配置都需要放到这个配置文件中。 4.2 YAML格式YAML 格式配置文件的扩展名可以是yaml 或者yml。 4.2.1基本格式要求 大小写敏感 使用缩进代表层级关系 相同的部分只出现一次 4.3 配置文件的存放与加载4.3.1存放位置 当前项目的根目录（或此目录下的/config目录） 当前项目resources目录（或此目录下的/config目录） 4.3.2 不同格式的加载顺序如果同一个目录下，同时存在application.yml和application.properties，默认先读取application.properties，同一个配置属性，在多个文件中配置，默认使用第一个读取到的，后面读取的不覆盖。 4.3.3 不同位置的加载顺序（加载优先级顺序） 当前项目根目录下的/config子目录中（最高）config/application.propertiesconfig/application.yml 当前项目根目录中(其次)application.propertiesapplication.yml 项目的resources 即classpath 根路径下的/config 目录中(一般)resources/config/application.propertiesresources/config/application.yml 项目的resources 即classpath 根路径中(最后)resources/application.propertiesresources/application.yml $\\color{red}{总结：外层优先即根目录/config优先，p优先（p、y字母顺序）}$ 4.4 配置文件中的占位符4.4.1 语法：${}4.4.2占位符作用 “${}”中可以获取框架提供的方法中的值如：random.int 等。 占位符可以获取配置文件中的键的值赋给另一个键作为值。 4.4.3生成随机数 ${random.value} - 类似uuid 的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200 范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10 以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 5. SpringBoot的核心注解5.1@SpringBootApplication是SpringBoot 的启动类。此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。 5.2@SpringBootConfiguration@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是springboot的注解，而@Configuration 是spring 的注解 5.3@Configuration通过对bean 对象的操作替代spring 中xml 文件 5.4@EnableAutoConfigurationSpring Boot 自动配置（auto-configuration）：尝试根据你添加的jar 依赖自动配置你的Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)注解的组合。 5.5@AutoConfigurationPackage@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类（@Controller，@Service 等），以及配置类（@Configuration） 5.6@Import({AutoConfigurationImportSelector.class})直接导入普通的类导入实现了ImportSelector 接口的类导入实现了ImportBeanDefinitionRegistrar 接口的类 5.7@ComponentScan组件扫描，可自动发现和装配一些Bean。 5.8@ConfigurationPropertiesScan@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作用是使用@ConfigurationProperties 注解的类生效。 6. 在项目中创建Controllerpackage com.kerr.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * 处理请求Controller */ @RestController // @Controller+@ResponseBody 直接返回字符串/json串 public class Demo1Controller { @RequestMapping(&quot;/helloWorld&quot;) public String showHelloWorld(){ return &quot;HelloWorld&quot;; } } 6.1Spring Boot 在Controller 中常用注解6.1.1 @RestController@RestController 相当于@Controller+@ResponseBody 注解如果使用@RestController 注解Controller 中的方法无法返回页面，相当于在方法上面自动加了@ResponseBody 注解， 所以没办法跳转并传输数据到另一个页面， 所以InternalResourceViewResolver 也不起作用，返回的内容就是Return 里的内容。 6.1.2 @GetMapping@GetMapping 注解是@RequestMapping(method = RequestMethod.GET)的缩写。 6.1.3 @PostMapping@PostMapping 注解是@RequestMapping(method = RequestMethod.POST)的缩写。 6.1.4 @PutMapping@PutMapping 注解是@RequestMapping(method = RequestMethod.PUT)的缩写。 6.1.5 @DeleteMapping@DeleteMapping 注解是@RequestMapping(method = RequestMethod.DELETE)的缩写。 7. SpringBoot整合Web层技术(2种方式)7.1 整合Servlet方式17.1.1 通过注解扫描完成Servlet组件的注册7.1.2 通过方法完成Servlet 组件的注册","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：SpringBoot","slug":"JavaEE开发框架：SpringBoot","permalink":"/tags/JavaEE开发框架：SpringBoot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2020-10-05T07:30:45.000Z","updated":"2020-10-05T07:30:47.356Z","comments":true,"path":"2020/10/05/SpringBoot入门/","link":"","permalink":"/2020/10/05/SpringBoot入门/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：SpringBoot","slug":"JavaEE开发框架：SpringBoot","permalink":"/tags/JavaEE开发框架：SpringBoot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"端口被占用的解决办法","slug":"端口被占用的解决办法","date":"2020-10-04T08:04:10.000Z","updated":"2020-10-04T08:33:03.458Z","comments":true,"path":"2020/10/04/端口被占用的解决办法/","link":"","permalink":"/2020/10/04/端口被占用的解决办法/","excerpt":"","text":"Q： 可以看到：4000端口被占用了，首先查到是哪个程序占用了该端口，然后杀掉！ A：打开cmd，输入以下命令： netstat -ano|findstr 4000 查询结果如下： 输入以下命令，来关掉被占用的端口： taskkill /t /f /im 11184 终止结果如下： 最后重新运行该端口程序即可。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"操作系统OS","slug":"操作系统OS","permalink":"/tags/操作系统OS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"012-Hashtable&HashMap&ConcurrentHashMap","slug":"012-Hash","date":"2020-10-04T06:18:44.000Z","updated":"2020-10-04T07:54:41.164Z","comments":true,"path":"2020/10/04/012-Hash/","link":"","permalink":"/2020/10/04/012-Hash/","excerpt":"","text":"附：验证HashMap线程不安全// 验证HashMap线程不安全 /** * 具体做法： * 启动多个线程操作同一个HashMap，不断往里面put * 过一段时间，内部发生死锁 */ public class HashMapTest { public static void main(String[] args) { Mythead mt1 = new Mythead(); Mythead mt2 = new Mythead(); Mythead mt3 = new Mythead(); Mythead mt4 = new Mythead(); Mythead mt5 = new Mythead(); mt1.start(); mt2.start(); mt3.start(); mt4.start(); mt5.start(); } } class Mythead extends Thread { // 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程要做什么？） private static AtomicInteger ai = new AtomicInteger(); // 原子类型 private static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); @Override public void run() { while (ai.get() &lt; 10000000) { map.put(ai.get(), ai.get()); ai.incrementAndGet(); } } } #1，首先，来看看其他几个相关的类 Hashtable是线程安全的，但效率低HashMap是线程不安全的，但效率高Collections.synchronizedMap()，工具类提供了同步包装器的方法，来返回具有线程安全的集合对象性能依然有问题 public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) { return new SynchronizedMap&lt;&gt;(m); } //在这个类的内部方法实现上，也只是单纯加上了锁 public V put(K key, V value) { synchronized (mutex) {return m.put(key, value);} } 为解决这样的矛盾问题，所以JDK提供了并发包，来平衡这样的问题（java.util.concurrent） *2，ConcurrentHashMap（重点） 兼顾了线程安全和效率的问题 分析：HashTable锁了整段数据（用户操作是不同的数据段，依然需要等待）解决方案：把数据分段，执行分段锁（分离锁），核心把锁的范围变小，这样出现并发冲突的概率就变小在保存的时候，计算所存储的数据是属于哪一段，只锁当前这一段 注意：分段锁（分离锁）是JDK1.8之前的一种的方案，JDK1.8之后做了优化。 JDK1.7跟JDK1.8在ConcurrentHashMap的实现上存在以下区别： 1，数据结构JDK1.7采用链表的方式，而JDK1.8则采用链表+红黑树的方式 2，发生hash碰撞之后JDK1.7发生碰撞之后，会采用链表的方式来解决 JDK1.8发生碰撞之后，默认采用链表，但当链表的长度超过8，且数组容量超过64时，会转换为红黑树存储 3，保证并发安全JDK1.7采用分段锁的方式，而JDK1.8采用CAS和synchronized的组合模式 4，查询复杂度JDK1.7采用链表的方式，时间复杂度为O(n)，而JDK1.8在采用红黑树的方式时，时间复杂度为O(log(n)) 题外话： 不过红黑树其实是一种兜底方案，因为当链表数量达到8个的时候，其发生的概率是千万分之几，所以作者考虑到这种极端情况下，需要用红黑树的方式来优化 场景选择","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"011-HashSet的存储原理","slug":"011-HashSet的存储原理","date":"2020-10-04T06:10:39.000Z","updated":"2020-10-04T06:19:36.164Z","comments":true,"path":"2020/10/04/011-HashSet的存储原理/","link":"","permalink":"/2020/10/04/011-HashSet的存储原理/","excerpt":"","text":"HashSet的存储原理或者工作原理，主要是从如何保证唯一性来说起。 这里面主要有3个问题，需要回答？ [x] 第一，为什么要采用Hash算法？有什么优势，解决了什么问题？ [x] 第二，所谓哈希表是一张什么表？ [x] 第三，HashSet如何保证保存对象的唯一性？会经历一个什么样的运算过程？ 首先，我们要明确一点，HashSet底层采用的是HashMap来实现存储，其值作为HashMap的key public boolean add(E e) { return map.put(e, PRESENT)==null; } 具体关于hashmap的细节再说 第一，为什么要采用Hash算法？有什么优势，解决了什么问题？ 解决的问题是唯一性 存储数据，底层采用的是数组 当我们往数组放数据的时候，你如何判断是否唯一？ 可以采用遍历的方式，逐个比较，但是这种效率低，尤其是数据很多的情况下 所以，为了解决这个效率低的问题，我们采用新的方式 采用hash算法，通过计算存储对象的hashcode，然后再跟数组长度-1做位运算，得到我们要存储在数组的哪个下标下，如果此时计算的位置没有其他元素，直接存储，不用比较。 此处，我们只会用到hashCode 但是随着元素的不断添加，就可能出现“哈希冲突”，不同的对象计算出来的hash值是相同的，这个时候，我们就需要比较，才需要用到equals方法 如果equals相同，则不插入，不相等，则形成链表 第二，所谓哈希表是一张什么表？ 本质是一个数组，而且数组的元素是链表 JDK1.7的版本实现 JDK1.8做了优化 随着元素不断添加，链表可能会越来越长，会优化为红黑树","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"010-双向链表中插入元素的具体实现","slug":"010-双向链表中插入元素的具体实现","date":"2020-10-04T02:38:20.000Z","updated":"2020-10-04T02:54:57.999Z","comments":true,"path":"2020/10/04/010-双向链表中插入元素的具体实现/","link":"","permalink":"/2020/10/04/010-双向链表中插入元素的具体实现/","excerpt":"","text":"双向链表是如何插入元素的呢？ 初始条件：A、B分别为链表中的两个相邻节点，A.next为B，B.pre为A； Q：若要在二者之间插入C节点，伪代码如下： C.pre = A; // C的前向指针指向A C.next = A.next; // C的后向指针指向A的后向指针位置 // 此时AB还牵着手，没断开 A.next.pre = C; A.next = C; [x] 图示：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"转载开篇","slug":"转载开篇","date":"2020-10-02T07:54:44.000Z","updated":"2020-10-02T07:58:45.628Z","comments":true,"path":"2020/10/02/转载开篇/","link":"","permalink":"/2020/10/02/转载开篇/","excerpt":"","text":"https://www.bilibili.com/read/cv6490548","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"随想开篇","slug":"随想开篇","date":"2020-10-02T07:48:27.000Z","updated":"2020-10-02T07:50:35.108Z","comments":true,"path":"2020/10/02/随想开篇/","link":"","permalink":"/2020/10/02/随想开篇/","excerpt":"","text":"Hello, world &amp; life.","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"心情","slug":"心情","permalink":"/tags/心情/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"发发的资源","slug":"发发的资源","date":"2020-10-02T07:15:54.000Z","updated":"2020-10-02T07:22:06.672Z","comments":true,"path":"2020/10/02/发发的资源/","link":"","permalink":"/2020/10/02/发发的资源/","excerpt":"","text":"链接：https://pan.baidu.com/s/1MRtmDgWD4lSp6aeRB6y4fw提取码：1mft","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"谈谈ArrayList和LinkedList的区别","slug":"009-谈谈ArrayList和LinkedList的区别","date":"2020-10-02T05:41:02.000Z","updated":"2020-10-02T06:21:44.729Z","comments":true,"path":"2020/10/02/009-谈谈ArrayList和LinkedList的区别/","link":"","permalink":"/2020/10/02/009-谈谈ArrayList和LinkedList的区别/","excerpt":"","text":"1，底层数据结构的差异 ArrayList，数组，连续一块内存空间LinkedList，双向链表，不是连续的内存空间 2，一个常规的结论虽然不严谨，但也可以应付很多面试了 ArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。 3，ArrayList细节分析1，增加 添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容 数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小 怎么扩容？ 当发现容量不够之后，就进行扩容 按原先数组容量的1.5倍进行扩容，通过位运算（效率高），下面是关键的源码 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 再将原先数组的元素复制到新数组，Arrays elementData = Arrays.copyOf(elementData, newCapacity) 添加到其他位置，这个时候需要做整体的搬迁 2，删除 删除末尾，并不需要迁移 删除其他的位置，这个时候也需要搬迁 3，修改 修改之前，必须先定位 定位-查找-ArrayList（数组是一段连续的内存空间，定位会特别快） 4，查找 如上所述 4，LinkedList细节分析1，提供了的两个引用（first，last）2，增加添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的pre，新节点设置为last 我们看下源码： void linkLast(E e) { //获取到最后一个节点 final Node&lt;E&gt; l = last; //构建一个新节点，将当前的last作为这个新节点的pre final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //把last指向新节点 last = newNode; //如果原先没有最后一个节点 if (l == null) //将first指向新节点 first = newNode; else //否则，将原先的last的next指向新节点 l.next = newNode; size++; modCount++; } Node节点的定义：内部类 private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } 添加到其他位置，这个时候，就需要调整前后节点的引用指向 3，如何去定义一个双向链表的节点，如上述的源码所示4，修改修改最后一个节点或者第一个节点，那么就很快（first，last） 修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下： if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } 5，一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，哪个更耗内存，为什么？ 6，LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"008-List和Set的区别","slug":"008-List和Set的区别","date":"2020-10-02T05:35:13.000Z","updated":"2020-10-02T06:16:01.783Z","comments":true,"path":"2020/10/02/008-List和Set的区别/","link":"","permalink":"/2020/10/02/008-List和Set的区别/","excerpt":"","text":"List（有序，可重复）：子类-&gt;ArrayList、LinkedList Set（无序，不可重复）：子类-&gt;HashSet、TreeSet（此无序！=可排序） Collections和Collection的区别： ​ Java里工具类的命名：+s结尾","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"007-方法的重写和重载的区别","slug":"007-方法的重写和重载的区别","date":"2020-10-02T05:29:57.000Z","updated":"2020-10-02T05:32:39.033Z","comments":true,"path":"2020/10/02/007-方法的重写和重载的区别/","link":"","permalink":"/2020/10/02/007-方法的重写和重载的区别/","excerpt":"","text":"重载：发生在一个类里面，方法名相同，参数列表不同（混淆点：跟返回类型没关系） 以下不构成重载public double add(int a,int b)public int add(int a,int b)​ 重写：发生在父类子类之间的，方法名相同，参数列表相同","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"006.Integer和int","slug":"006-Integer和int","date":"2020-10-02T05:22:55.000Z","updated":"2020-10-02T05:29:38.903Z","comments":true,"path":"2020/10/02/006-Integer和int/","link":"","permalink":"/2020/10/02/006-Integer和int/","excerpt":"","text":"public static void main(String[] args){ Integer i1 = new Integer(12); Integer i2 = new Integer(12); System.out.println(i1 == i2); // false Integer i3 = 126; Integer i4 = 126; // 反编译工具 Integer.valueOf(126); int i5 = 126; System.out.println(i3 == i4); // true System.out.println(i3 == i5); // true 自动拆箱，数值 Integer i6 = 128; Integer i7 = 128; int i8 = 128; System.out.println(i6 == i7); // false System.out.println(i6 == i8); // true 自动拆箱，数值 } 第一个sout（sout指的是System.out.println()）中，是两个引用类型比较，比较的是地址，很显然，i1和i2是new出来的，因此占用了两块堆空间，也就是说i1和i2的地址不一样。 第二个：i3和i4是基本类型，都没有new；而左边是Integer类引用类型，因此这种语句有一个装箱操作； 而基本类型赋值给引用类型，需要装箱操作。JDK1.5之后，有自动装箱操作。i3 i4都还在缓存最小值low-128和最大值high127之间，直接用缓存里面的数据，答案是true。如果超出这个范围，需要重新new一个出来，这样的话结果就不一样了。 第三个：当引用类型和基本类型比较时，需要进行自动拆箱，将包装类Integer转换成int型，最后比较的是二者的数值。所以答案是true。 第四个：128已经越界，因此需要new一个出来，那么两个引用类型比较，比较地址，二者分别new，地址肯定不一样。 第五个：同第三个。 结论：1️⃣、引用类型和引用类型比较，需要判断是否越界[-128,127]： 1）不越界：true；因为不需要new； 2）越界：false；因为需要new。 2️⃣、引用类型和基本类型比较，直接看数值，因为引用类型要自 动拆箱，然后再比较。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"记第一次喝吐~~~","slug":"记第一次喝吐","date":"2020-09-28T13:37:34.000Z","updated":"2020-09-28T13:56:26.586Z","comments":true,"path":"2020/09/28/记第一次喝吐/","link":"","permalink":"/2020/09/28/记第一次喝吐/","excerpt":"","text":"2020年9月27日晚九点半左右，为老磊庆生（实际上生日早就过去了好几天~~~）。 ​ 逞能了一把，以为自己白啤配很能喝。。。先喝了一杯啤的润润口，然后蹦起来白的倒满，快速的喝完之后，接着玩起了游戏，没想到竟然大大的输了一把。。。用一个大的喝扎啤的杯子倒了满满一杯（应该一瓶啤酒的量），吨吨吨~喝完之后想撒尿。。。撤硕有yin，就站那等着。我是万万妹想到啊，越站越晕，等里边俩男的出来之后，额不对，没记错的话是三个男的，从一个两平出头的小撤硕出来了。然后我上完撤硕之后回去就不行了，开始出汗，脸色苍白，有了晕车那种感觉。。。就趴那里等其他人玩完游戏回家。​ 十几分钟后，晚宴结束，出了门，老磊付款的时候，我坚持不住，吐院子里了~~~​ 事后，大家对我都特好，又是送水又是问候。。。太温暖了~","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"005.递归必备掌握题目","slug":"005-递归必备掌握题目","date":"2020-09-28T09:07:56.000Z","updated":"2020-09-28T09:12:11.599Z","comments":true,"path":"2020/09/28/005-递归必备掌握题目/","link":"","permalink":"/2020/09/28/005-递归必备掌握题目/","excerpt":"","text":"递归这道算法题一般考查的递归的编程技能，那么我们回顾下递归程序的特点： 1，什么是递归？ 递归，就是方法内部调用方法自身递归的注意事项：找到规律，编写递归公式找到出口（边界值），让递归有结束边界 注意：如果递归太多层，或者没有正确结束递归，则会出现“栈内存溢出Error”！ 问题：为什么会出现栈内存溢出，而不是堆内存溢出？ ​ 因为每次调用的方法是在栈中创建栈帧的空间，而不是堆。 2，这道题该怎么写？ 规律：N!=（n-1）!*n; 出口：n == 1或 n == 0 return 1; /** * 1.n的阶乘 * @param n * @return */ public static int getResult(int n) { if (n &lt; 0) { throw new IllegalArgumentException(&quot;非法参数&quot;); } if (n == 0 || n == 1) { return 1; } return getResult(n - 1) * n; } 3，如何实现递归求斐波那切数列第N个数字的值（传说中的不死神兔就是这个问题） 数字的规律：1,1,2,3,5,8,13,21….（第三个数等于前两个数之和） 所以，我们可以分析编写如下： /** 规律：每个数等于前两个数之和 出口：第一项和第二项都等于1 */ /** * 2. 斐波那契数列（求第n项的值） * @param n * @return */ public static int getFeiBo(int n){ if (n&lt;0){ return -1; } if (n==0 || n==1){ return 1; }else{ return getFeiBo(n-1)+getFeiBo(n-2); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"004.接口和抽象类","slug":"004-接口和抽象类","date":"2020-09-28T09:03:45.000Z","updated":"2020-09-28T09:06:31.030Z","comments":true,"path":"2020/09/28/004-接口和抽象类/","link":"","permalink":"/2020/09/28/004-接口和抽象类/","excerpt":"","text":"接口和抽象类这个问题，要分JDK版本来区分回答： JDK1.8之前： 语法： 抽象类：方法可以有抽象的，也可以有非抽象, 有构造器 接口：方法都是抽象，属性都是常量，默认有public static final修饰（接口实际上就是一种契约） 设计： 抽象类：同一类事物的抽取，比如针对Dao层操作的封装，如，BaseDao，BaseServiceImpl 接口：通常更像是一种标准的制定，定制系统之间对接的标准 例子： 1，单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao 2，分布式项目，面向服务的开发，抽取服务service，这个时候，就会产生服务的提供者和服务的消费者两个角色 这两个角色之间的纽带，依然是接口 JDK1.8之后： 接口里面可以有实现的方法，注意要在方法的声明上加上default或者static 最后区分几个概念： 多继承，多重继承，多实现 多重继承：A-&gt;B-&gt;C（爷孙三代的关系） 多实现：Person implements IRunable,IEatable（符合多项国际化标准） 多继承：接口可以多继承，类只支持单继承 面向接口编程的好处：解耦。比如分层开发的时候，上一层调用下一层，为了解耦，不要调具体的实现，要使用接口将二者连接起来，那么上层和下层就解耦了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"003.String_StringBuffer_String_Builder的区别","slug":"003-String-StringBuffer-String-Builder的区别","date":"2020-09-28T08:59:27.000Z","updated":"2020-09-28T09:03:54.472Z","comments":true,"path":"2020/09/28/003-String-StringBuffer-String-Builder的区别/","link":"","permalink":"/2020/09/28/003-String-StringBuffer-String-Builder的区别/","excerpt":"","text":"String 跟其他两个类的区别是 String是final类型，每次声明的都是不可变的对象，所以每次操作都会产生新的String对象，然后将指针指向新的String对象。 StringBuffer，StringBuilder都是在原有对象上进行操作 所以，如果需要经常改变字符串内容，则建议采用这两者。 StringBuffer vs StringBuilder 前者是线程安全的，后者是线程不安全的。线程不安全性能更高，所以在开发中，优先采用StringBuilder.StringBuilder &gt; StringBuffer &gt; String（性能比较） StringBuffer中每个方法都加了synchronized修饰关于选用哪个类的场景“不考虑安全的情况，选用StringBuilder；不考虑安全的情况，选用StringBuffer。”的说法是错误的！！！ 因为当多线程情况下才需要考虑这些，单线程是不需要考虑的。直接上性能！ 开发中，用StringBuider来解决什么问题？字符拼接： ​ 在方法内使用：StringBuilder.append(“”);","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"002.final的用法及相关注意点","slug":"002-final的用法及相关注意点","date":"2020-09-28T03:46:49.000Z","updated":"2020-09-28T09:02:32.058Z","comments":true,"path":"2020/09/28/002-final的用法及相关注意点/","link":"","permalink":"/2020/09/28/002-final的用法及相关注意点/","excerpt":"","text":"final修饰类，表示类不可变，不可继承 比如，String，不可变性 final修饰方法，表示该方法不可重写 比如模板方法，可以固定我们的算法 final修饰变量，这个变量就是常量 注意： 修饰的是基本数据类型，这个值本身不能修改 修饰的是引用类型，引用的指向不能修改 比如下面的代码是可以的 final Student student = new Student(1,&quot;Andy&quot;); student.setAge(18);//注意，这个是可以的！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"001.“==” 与 equals的区别","slug":"001-==和equals的区别","date":"2020-09-28T03:00:00.000Z","updated":"2020-09-28T09:02:12.703Z","comments":true,"path":"2020/09/28/001-==和equals的区别/","link":"","permalink":"/2020/09/28/001-==和equals的区别/","excerpt":"","text":"“==” 与 equals的区别 == 比较的是值比较基本的数据类型，比较的是数值 比较引用类型：比较引用指向的值（地址） equals默认比较也是地址，因为这个方法的最初定义在Object上，默认的实现就是比较地址 自定义的类，如果需要比较的是内容，那么就要学String，重写equals方法 代码案例：测试以下的每道题，你是否能够正确得到答案？ String s = “java”; String s = new String(“java”); 这两者的内存分配方式是不一样的。 第一种方式，JVM会将其分配到常量池，而第二种方式是分配到堆内存 /** * 测试 == 和 eauals */ @Test public void test01(){ String s1 = new String(&quot;zs&quot;); String s2 = new String(&quot;zs&quot;); System.out.println(s1 == s2); // false String s3 = &quot;zs&quot;; // 指向常量池地址 String s4 = &quot;zs&quot;; System.out.println(s3 == s4); // true System.out.println(s3 == s1); // false String s5 = &quot;zszs&quot;; String s6 = s3+s4; System.out.println(s5 == s6); // false ：字符串是个不可变对象，相加时需要创建新对象（相当于new了一下） 用反编译工具验证 final String s7 = &quot;zs&quot;; // final修饰的不再是变量，是常量 final String s8 = &quot;zs&quot;; String s9 = s7+s8; // 编译器在处理常量运算的时候，会进行优化，将二者之和再转变为常量 System.out.println(s5 == s9); // true final String s10 = s3+s4; // 右边依然是变量，所以创建的时候还是要new，而final是影响的s10，而不会影响s3+s4的特性 System.out.println(s5 == s10); // false }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"写发文章步骤.md","slug":"Hexo写发文章步骤","date":"2020-09-28T02:22:01.000Z","updated":"2020-10-02T06:34:58.103Z","comments":true,"path":"2020/09/28/Hexo写发文章步骤/","link":"","permalink":"/2020/09/28/Hexo写发文章步骤/","excerpt":"","text":"1、编辑 2、本地预览在博客文件夹右键Bash，输入（hexo generate） hexo g 生成之后，再输入（hexo server的简写） hexo s 来启动博客，通过给定的地址进行本地预览。 2、发布 发布到github Ctrl+C停止本地预览。 输入(hexo deploy) hexo d 将改动后的博客部署到github上。在网络畅通的情况下，很快可以刷新出更新后的博客。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Hexo写文章","slug":"Hexo写文章","permalink":"/tags/Hexo写文章/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}