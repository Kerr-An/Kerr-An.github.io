{"meta":{"title":"Kerr&Ann","subtitle":null,"description":"长路漫漫任我闯↗↗","author":"Kerr","url":""},"pages":[{"title":"about","date":"2020-07-10T12:31:42.585Z","updated":"2020-07-10T12:31:42.585Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"books","date":"2020-10-02T08:19:25.000Z","updated":"2020-10-02T08:25:49.327Z","comments":false,"path":"books/index.html","permalink":"/books/index.html","excerpt":"","text":"","keywords":"书单"},{"title":"bangumi","date":"2020-09-28T13:29:29.659Z","updated":"2020-07-10T12:14:27.113Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"categories","date":"2020-10-02T06:59:49.000Z","updated":"2020-10-02T07:02:11.808Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-09-28T13:30:09.643Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2020-10-02T08:14:20.285Z","updated":"2020-10-02T08:14:20.285Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"pictures","date":"2020-10-02T08:22:04.000Z","updated":"2020-10-02T08:41:56.578Z","comments":false,"path":"pictures/index.html","permalink":"/pictures/index.html","excerpt":"","text":"","keywords":"美图"},{"title":"tags","date":"2020-10-02T06:51:44.000Z","updated":"2020-10-02T07:03:51.725Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-10T12:15:37.778Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-10-02T07:24:57.237Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2020-10-02T06:51:44.000Z","updated":"2020-10-02T07:04:05.990Z","comments":true,"path":"tags/index-1.html","permalink":"/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"如何自定义线程池","slug":"如何自定义线程池","date":"2020-11-16T16:07:40.000Z","updated":"2020-11-16T16:08:01.919Z","comments":true,"path":"2020/11/17/如何自定义线程池/","link":"","permalink":"/2020/11/17/如何自定义线程池/","excerpt":"","text":"线程每次创建和关闭的开销非常大，我们可以使用线程池来管理我们的线程，可以充分利用线程，减少不必要的开销。 1. 创建线程的方式有三种：1、继承Thread类 2、实现Runable或者Callable（带返回值）接口 3、线程池的方式启动 2.线程池今天我们主要针对线程池来进行展开讨论： JDK自带创建线程的方式有多种： 这里是针对JDK1.8版本。每个创建都不一样，但是使用JDK自带的线程池会出现OOM问题，中小型公司一般狠难遇到，在阿里巴巴开发文档上面有明确的标识： 如果有需要此文档，请点击下面的url进行下载：https://www.cnblogs.com/han-1034683568/p/7680354.html 既然JDK自带的线程池我们不能用，那么我们要自己手动来写线程池了， 如果创建一个线程池： 2.1 创建我们可以这样来创建线程池，其他里面的参数表示什么意思，我们在这里说明一下啊： ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) 2.2 参数 参数 作用 corePoolSize 线程中常驻核心线程数 maximumPoolSize 线程池能够容纳同时执行的最大线程数，此值必须大于1 keepAliveTime 多余空闲线程的存活时间 unit keepAliveTime的单位 workQueue 任务队列，被提交但尚未被执行的任务 threadFactory 表示生成线程池中工作线程的线程工厂，用于创建线程，一般的默认即可 handler 拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize） 2.3 拒绝策略线程池的拒绝策略： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认） ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务添加阻塞队列的方式有四种： 1、add，添加不进去的时候，就会抛异常 2、offer，添加进去返回true，添加不进去返回false 3、put，会一直阻塞，直到可以放进去为止 4、offer+时间，如果阻塞队列满的时候，往阻塞队列添加，多久没有添加进去，则停止添加如何合理的配置线程池： 这看你的业务了，看你的业务是CPU密集还是IO密集 如果是CPU密集，一般配置的是CPU的核数或者核数+1 如果是IO密集，大部分的线程都会阻塞，则需要多配置线程数，公式（CPU/(1-阻塞系数)），阻塞系数在0.8-0 3. 总体步骤： 创建及使用线程池的步骤 1、在创建线程后，等待提交过来的任务请求 2、当调用execute()方法添加一个请求任务的时候，线程池会如何判断 2.1、如果正在运行的线程数小于corePoolSize，那么马上创建线程运行这个认为 2.2、如果正在运行的线程数大于等于corePoolSize，那么将这个认为放入队列 2.3、如果这个时候队列满了，且小于maximumPoolSize，那么还是要创建线程立即执行任务 2.4、如果队列满了，maximumPoolSize也满了，将会启动饱和拒绝策略来执行 3、将一个线程完成任务的时候，他会冲=从队列里面取下一个任务来执行 4、当一个线程无事的时候，超过一定时间的时候，线程池会判断：如果当前运行的线程数大于等于corePoolSize，那么这个线程将被停掉，所以线程池的所有任务完成后它最终收缩到corePoolSize的大小","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"/tags/线程池/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"深挖数据库（MySQL）","slug":"深挖数据库（MySQL）","date":"2020-11-16T14:48:04.000Z","updated":"2020-11-16T15:05:03.390Z","comments":true,"path":"2020/11/16/深挖数据库（MySQL）/","link":"","permalink":"/2020/11/16/深挖数据库（MySQL）/","excerpt":"","text":"文章目录 1.事务四大特性 2.数据库隔离级别 3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景 4.索引有B+索引和hash索引 5.聚集索引和非聚集索引 6.索引的优缺点，什么时候使用索引，什么时候不能使用索引 7.InnoDB索引和MyISAM索引的区别 8.索引的底层实现（B+树，为何不采用红黑树，B树）重点 9.B+树的实现 10.为什么使用B+Tree 11.Sql的优化 12.索引最左前缀问题 13.索引分类，索引失效条件 14.数据库的主从复制 15.long_query怎么解决 16.varchar和char的使用场景 17.数据库连接池的作用 19.分库分表，主从复制，读写分离 20.数据库三范式 21.关系型数据库和非关系型数据库区别 22.数据库中join的left join , inner join, cross join 23.有哪些锁,select时怎么加排它锁 24.死锁怎么解决 25.最左匹配原则 1.事务四大特性 原子性，要么执行，要么不执行 隔离性，所有操作全部执行完以前其它会话不能看到过程 一致性，事务前后，数据总额一致 持久性，一旦事务提交，对数据的改变就是永久的 1234567 2.数据库隔离级别 多个事务读可能会道理以下问题脏读：事务B读取事务A还没有提交的数据不可重复读：，一行被检索两次，并且该行中的值在不同的读取之间不同时幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回 的集合不一样 示例图，Id =1这一行 幻读，返回的集合不一样 隔离级别总结 3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景 引擎 特性 MYISAM 不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描 INNODB 支持外键，行锁，查表总行数时，全表扫描 4.索引有B+索引和hash索引 索引 区别 Hash hash索引，等值查询效率高，不能排序,不能进行范围查询 B+ 数据有序,范围查询 5.聚集索引和非聚集索引 索引 区别 聚集索引 数据按索引顺序存储，中子结点存储真实的物理数据 非聚集索引 存储指向真正数据行的指针 6.索引的优缺点，什么时候使用索引，什么时候不能使用索引索引最大的好处是提高查询速度， 缺点是更新数据时效率低，因为要同时更新索引 对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。 7.InnoDB索引和MyISAM索引的区别一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。 二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主索引 8.索引的底层实现（B+树，为何不采用红黑树，B树）重点 树 区别 红黑树 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间 B树也就是B-树 B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。（说白了还是怕磁盘io操作过多） B+树 B+树相比较于另外两种树,显得更矮更宽，查询层次更浅 9.B+树的实现一个m阶的B+树具有如下几个特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素 10.为什么使用B+Tree索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。 根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理， 将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入 局部性原理与磁盘预读 11.Sql的优化1.sql尽量使用索引,而且查询要走索引 2.对sql语句优化 子查询变成left join limit 分布优化，先利用ID定位，再分页 or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复） 不必要的排序 where代替having,having 检索完所有记录，才进行过滤 避免嵌套查询 对多个字段进行等值查询时，联合索引 1234567 12.索引最左前缀问题如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了 1 13.索引分类，索引失效条件 索引类型 概念 普通索引 最基本的索引，没有任何限制 唯一索引 与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。 主键索引 它是一种特殊的唯一索引，不允许有空值。 全文索引 针对较大的数据，生成全文索引很耗时好空间。 组合索引 为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则 失效条件 条件是or,如果还想让or条件生效，给or每个字段加个索引 like查询，以%开发 内部函数 对索引列进行计算 is null不会用，is not null 会用 123456 14.数据库的主从复制 复制方式 操作 异步复制 默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志 半同步复制 只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低 并行操作 slave 多个线程去请求binlog日志 15.long_query怎么解决设置参数，开启慢日志功能，得到耗时超过一定时间的sql 16.varchar和char的使用场景 类型 使用场景 varchar 字符长度经常变的 char 用字符长度固定的 17.数据库连接池的作用维护一定数量的连接，减少创建连接的时间 更快的响应时间 统一的管理 19.分库分表，主从复制，读写分离读写分离，读从库，写主库 spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。 20.数据库三范式 级别 概念 1NF 属性不可分 2NF 非主键属性，完全依赖于主键属性 3NF 非主键属性无传递依赖 21.关系型数据库和非关系型数据库区别关系型数据库 优点 1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解； 2、使用方便：通用的SQL语言使得操作关系型数据库非常方便； 3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率； 4、支持SQL，可用于复杂的查询。 5.支持事务 缺点 1、为了维护一致性所付出的巨大代价就是其读写性能比较差； 2、固定的表结构； 3、不支持高并发读写需求； 4、不支持海量数据的高效率读写 非关系型数据库 1、使用键值对存储数据； 2、分布式； 优点 无需经过sql层的解析，读写性能很高 基于键值对，数据没有耦合性，容易扩展 存储数据的格式：nosql的存储格式是key,value形式 缺点 不提供sql支持 22.数据库中join的left join , inner join, cross join1.以A，B两张表为例 A left join B 选出A的所有记录，B表中没有的以null代替 right join 同理 2.inner join A,B有交集的记录 3.cross join (笛卡尔积) A中的每一条记录和B中的每一条记录生成一条记录 例如A中有4条，B中有4条，cross join 就有16条记录 23.有哪些锁,select时怎么加排它锁 锁 概念 乐观锁 自己实现，通过版本号 悲观锁 共享锁，多个事务，只能读不能写，加 lock in share mode 排它锁 一个事务，只能写，for update 行锁 作用于数据行 表锁 作于用表 24.死锁怎么解决找到进程号，kill 进程 1 25.最左匹配原则最左匹配原则是针对索引的 举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的， 这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了， 查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗， 按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了 26. where和having的区别1.WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。 2.GROUP BY 子句用来分组 WHERE 子句的输出。 3.HAVING 子句用来从分组的结果中筛选行","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"数据库-MySQL","slug":"数据库-MySQL","permalink":"/tags/数据库-MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"学生信息管理系统项目中遇到的问题总结","slug":"学生信息管理系统项目中遇到的问题总结","date":"2020-11-09T04:08:22.000Z","updated":"2020-11-12T14:49:13.189Z","comments":true,"path":"2020/11/09/学生信息管理系统项目中遇到的问题总结/","link":"","permalink":"/2020/11/09/学生信息管理系统项目中遇到的问题总结/","excerpt":"","text":"1.执行sql脚本时报错大概的错误提示 error: check the manual that corresponds to your MySQL server version 错误位置： 错误位置： 解决： 不是insert语句有问题，也不是create创建有问题，而是时间类型有问题,无论是datetime还是time，Navicat premium工具转储数据表的结构，时间后面都会带“(0)”!!! 把datetime(0)全替换成datetime或time(0) 2. post方法地址栏输入参数后 将post方法改为get，因为地址栏输入是get请求！！！ 3. 测试SSM时无法连接数据库本地mysql版本5.5.40，项目文件pom.xml里jar包驱动使用5.1.47，在地址栏输入参数后，出现“Cannot load JDBC driver class ‘com.mysql.cj.jdbc.Driver’”的错误。 解决办法是：（mysql 驱动jar文件 兼容性问题）驱动版本更改为6.0.6. 4. Layui转圈圈长时间加载不入的问题F12打开查错，发现是index.jsp接收不到后端传入的loginType，此时可以手动给loginType添加值（1代表管理员，2老师，3学生）；但这样写死的话显然不好。 在loginController中写入login方法，分别定义三种角色：如下，随着user的信息一同存入session中，在前端通过${type}获取登录角色类型，然后根据type的值传入对应的json数据，并展示对应的页面，即可实现动态判断登录角色。 @Controller public class LoginController { @Autowired private UserService userService; @Autowired private TeacherService teacherService; @Autowired private StudentService studentService; @GetMapping(&quot;/login&quot;) public String login() { return &quot;login&quot;; } @PostMapping(&quot;/login&quot;) @ResponseBody public Map&lt;String, Object&gt; login(String userName, String password, String type, String captcha, HttpSession session) { // 判断基本登录信息是否为空 if (StringUtils.isEmpty(userName) || StringUtils.isEmpty(password) || StringUtils.isEmpty(type)) { return MapControl.getInstance().error(&quot;用户名或密码不能为空！&quot;).getMap(); } // 判断验证码 String _captcha = (String) session.getAttribute(&quot;captcha&quot;); // 验证码不能为空 if (StringUtils.isEmpty(captcha)){ return MapControl.getInstance().error(&quot;验证码不能为空&quot;).getMap(); } // 验证码不匹配返回错误信息 if (!captcha.equals(_captcha)) { return MapControl.getInstance().error(&quot;验证码错误&quot;).getMap(); } // 判断登录类型： // 1管理员 if (&quot;1&quot;.equals(type)) { User user = userService.login(userName, MD5Utils.getMD5(password)); if (user != null) { session.setAttribute(&quot;user&quot;, user); session.setAttribute(&quot;type&quot;, &quot;1&quot;); return MapControl.getInstance().success().add(&quot;data&quot;,user).getMap(); } else { return MapControl.getInstance().error(&quot;用户名或密码错误&quot;).getMap(); } } // 2老师 if (&quot;2&quot;.equals(type)) { Teacher teacher = teacherService.login(userName, MD5Utils.getMD5(password)); if (teacher != null) { session.setAttribute(&quot;user&quot;, teacher); session.setAttribute(&quot;type&quot;, &quot;2&quot;); return MapControl.getInstance().success().add(&quot;data&quot;,teacher).getMap(); } else { return MapControl.getInstance().error(&quot;用户名或密码错误&quot;).getMap(); } } // 3学生 if (&quot;3&quot;.equals(type)) { Student student = studentService.login(userName, MD5Utils.getMD5(password)); if (student != null) { session.setAttribute(&quot;user&quot;, student); session.setAttribute(&quot;type&quot;, &quot;3&quot;); return MapControl.getInstance().success().add(&quot;data&quot;,student).getMap(); } else { return MapControl.getInstance().error(&quot;用户名或密码错误&quot;).getMap(); } } return MapControl.getInstance().getMap(); } } 5. 返回数据不符合Layui规范返回数据的代码中少了success()方法，导致返回的数据中缺失了定义在success方法中的信息（少了msg和code），因此查询出的数据不符合规范，Layui无法正常渲染。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"项目","slug":"项目","permalink":"/tags/项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"常用SQL","slug":"常用SQL","date":"2020-11-06T11:10:57.000Z","updated":"2020-11-06T13:24:55.252Z","comments":true,"path":"2020/11/06/常用SQL/","link":"","permalink":"/2020/11/06/常用SQL/","excerpt":"","text":"1、SQL1.1 什么是SQL？​ Structured Query Language：结构化查询语言​ 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 1.2 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: / 注释 / 1.3 SQL分类1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 2. DDL（操作数据库、表） 操作数据库 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 操作表 `sql C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; # 3. DML：增删改表中数据 ```sql 1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 4. DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &#39;___&#39;; 5. $$$ DQL:花式查询1. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含空的列进行计算 2. IFNULL函数 3. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 4. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot; 6. 约束* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; * 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; * 外键约束：foreign key,让表与表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 7.数据库的设计1. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 8. 多表查询* 查询语法： select 列名列表 from 表名列表 where.... 多表查询的分类： 1. 内连接查询： 1. 隐式内连接： 使用where条件消除无用数据 2. 显式内连接： 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 3. 内连接查询： 1. 从哪些表中查询数据 2. 条件是什么 3. 查询哪些字段 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。（交集：即满足条件的部分） 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 3. 子查询： * 概念：查询中嵌套查询，称嵌套查询为子查询。 * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 9. 事务 事务的基本介绍 概念： 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作： 开启事务： start transaction; 回滚：rollback; 提交：commit; 事务的四大特征： 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别（了解） 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle） 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认） 产生的问题：幻读 serializable：串行化 可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别： select @@tx_isolation; 数据库设置隔离级别： set global transaction isolation level 级别字符串;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"MySql常用语句语法总结","slug":"MySql常用语句语法总结","permalink":"/tags/MySql常用语句语法总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SSM框架项目之学生信息管理系统","slug":"SSM框架项目之学生信息管理系统","date":"2020-10-31T02:12:04.000Z","updated":"2020-11-08T14:18:45.786Z","comments":true,"path":"2020/10/31/SSM框架项目之学生信息管理系统/","link":"","permalink":"/2020/10/31/SSM框架项目之学生信息管理系统/","excerpt":"","text":"步骤概要1. idea新建maven工程新建的时候选择这个：maven-archetype-webapp。 2. 新建完成之后等待下载依赖删除pom.xml中不必要插件。 3. 在pom.xml中引入spring的jar包4. 配置spring核心配置文件5. 配置spring-MVC核心配置文件6. 配置web.xml7. 整合Mybatis8. 测试SSM框架","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：Spring","slug":"JavaEE开发框架：Spring","permalink":"/tags/JavaEE开发框架：Spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring笔记（下）","slug":"Spring学习笔记（下）","date":"2020-10-31T02:12:04.000Z","updated":"2020-11-04T08:35:08.556Z","comments":true,"path":"2020/10/31/Spring学习笔记（下）/","link":"","permalink":"/2020/10/31/Spring学习笔记（下）/","excerpt":"","text":"Spring5.2.0（下）spring中文文档https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans 官方英文文档https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace 8. 使用注解开发Spring4之后要使用注解开发，必须要保证AOP的包已经导入。 使用注解需要导入context约束，增加注解支持。 bean // @Component（组件） 注解等价于 &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;/&gt; @Component // 用来注册bean public class User {...} 属性如何注入一般简单的用注解注入，如果遇到复杂的，最好用xml：清晰明了 // @Component（组件） 注解等价于 &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;/&gt; @Component public class User { // @Value(&quot;Kerr&quot;) 注解等价于 &lt;property name=&quot;name&quot; value=&quot;kerr&quot;/&gt; @Value(&quot;Kerr&quot;) public String name; // 同样@Value(&quot;Kerr&quot;)注解也可以放在set方法上 @Value(&quot;Kerr&quot;) public void setName(String name) { this.name = name; } } 衍生的注解@component有几个衍生注解，在web开发中，会按照MVC三层架构分层！（下面的注解，功能相似） dao【@Repository】–&gt;仓库，一般dao层的使用这个注解 service【@Service】 controller【@Controller】 这4个注解功能一样，都是讲某个类注册到Spring中，装配bean。 自动装配 @Autowired：自动装配通过类型，名字； 如果@Autowired不能唯一地自动装配上属性，则需要通过@Qualifier(value=“”)。 @Nullable：字段标记了这个注解，说明这个字段可以为null。 @Resource：自动装配通过名字、类型。 作用域 @Scope(&quot;prototype&quot;) // 原型模式 public class User {...} 小结 xml与注解 xml更加万能，适用于任何场合，维护简单方便； 注解不是自己类使用不了，维护相对复杂 xml与注解的最佳实践 xml用于管理bean； 注解只负责完成属性的注入； 使用中需要注意一个问题：开始注解支持，并指定要扫描的包，让包下的注解生效。 &lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt; &lt;context:component-scan base-package=&quot;com.kerr&quot;/&gt; &lt;!--开启注解驱动的支持--&gt; &lt;context:annotation-config/&gt; 9. 使用java的方式配置Spring 现在我们要完全抛弃Spring的xml配置了，全权交给Java来做。 JavaConfig是Spring的一个子项目，在Spring4之后，他成为了一个核心功能。 这个时候，测试类中要使用AnnotationConfigApplicationContext来获取容器。（而不是pcx）。 实体类： // 这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中 @Component public class User { private String name; public String getName() { return name; } @Value(&quot;Kerr&quot;) public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;User{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;}&#39;; } } Java配置类： import com.kerr.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; // 这个会在容器中托管，注册到容器中，因为他本来就是一个@Component // @Configuration代表这是一个配置类，就和beans.xml一样 @Configuration @ComponentScan(&quot;com.kerr.pojo&quot;) // 用来扫描包 @Import(KerrConfig2.class) // 把KerrConfig2和KerrConfig融合在一起的方法 public class KerrConfig { // 注册一个bean，就相当于之前写的一个bean标签 // 这个方法的名字就相当于bean标签中的id属性 // 这个方法中的返回值就相当于bean标签的class属性 @Bean public User getUser(){ return new User();// 返回要注入到bean的对象 } } 测试类： public class MyTest { public static void main(String[] args) { // 如果完全使用了配置类方式去做，只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载 // 通过纯注解获取容器 ApplicationContext context = new AnnotationConfigApplicationContext(KerrConfig.class); User getUser = context.getBean(&quot;getUser&quot;, User.class); System.out.println(getUser.getName()); } } 这种纯Java的配置方式，在SpringBoot中随处可见！SpringBoot比SSM强！！！ 10. 代理模式 为什么要学习代理模式呢？因为这就是SpringAOP的底层！【SpringAOP 和 SpringMVC】重点 代理模式的分类： 静态代理 动态代理 10.1 静态代理角色分析： 抽象角色：一般会使用接口或抽象类来解决 // 租房 public interface Rent { public void rent(); } 真实角色：被代理的角色 // 房东 public class Host implements Rent{ public void rent() { System.out.println(&quot;房东要出租房子！&quot;); } } 代理角色：代理真实角色，之后会做一些附属操作 // 代理（中介） public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent() { seeHouse(); host.rent(); signContract(); fee(); } // 代理（中介）还可以带客户去看房 public void seeHouse(){ System.out.println(&quot;中介带你去看房！&quot;); } // 收中介费 public void fee(){ System.out.println(&quot;收中介费！&quot;); } // 签租赁合同 public void signContract(){ System.out.println(&quot;签租赁合同！&quot;); } } 客户：访问代理对象的人 // 客户 public class Client { public static void main(String[] args) { Host host = new Host(); // 代理，中介帮房东租房子，但是单利会附带一些附属操作 Proxy proxy = new Proxy(host); // 你不用面对房东，直接找中介租房即可！ proxy.rent(); } } 代理模式的好处： 使真实角色的操作更加纯粹！不用关注一些公共的业务！ 公共业务交代理角色，实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 代理模式的缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率变低。 10.2 静态代理加深理解 10.3 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类： 基于接口的动态代理——JDK动态代理==【我们在这里使用这个】== 基于类的动态代理——cglib Java字节码实现：javassist 需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序 动态代理的好处： 使真实角色的操作更加纯粹！不用关注一些公共的业务！ 公共业务交代理角色，实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 // 动态代理（工具类） import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 动态代理理解： * 1.Proxy和InvocationHandler是两个类 * 2.Proxy：生成动态代理实例 * 3.InvocationHandler：调用处理程序并返回结果 */ // 用这个类，自动生成代理类 /** 这程序只做两件事： * 1.invoke执行要真正执行的方法 * 2.得到代理类 */ public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 private Object target; public void setTarget(Object target) { this.target = target; } // 生成代理类（参数解释：1.为了加载到类在哪个位置，2.表示要代理的接口是哪一个，3.表示InvocationHandler，调用他来处理） public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例，并返回结果（执行方法） public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 利用method方法得到log内方法名 log(method.getName()); // 动态代理的本质，就是使用反射机制实现 Object result = method.invoke(target, args); return result; } public void log( String msg){ System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); } } // 测试类 /** * 怎么去得到代理类并执行方法？ * 1.调用host设置一个真实要代理的角色 * 2.获得代理类 */ public class Client { public static void main(String[] args) { // 真实角色 UserServiceImpl userService = new UserServiceImpl(); // 代理角色：现在没有 ProxyInvocationHandler pih = new ProxyInvocationHandler(); // 1.通过调用程序处理角色来处理我们要调用的接口对象！ pih.setTarget(userService); // 设置要代理的对象 // 2.获得代理类，动态生成。 UserService proxy = (UserService) pih.getProxy(); // 3.通过代理调用方法 proxy.add(); proxy.delete(); } } 11. AOP11.1 什么是AOPAOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合降低，提高程序的可重用性，同时提高了开发的效率。 11.2 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 。 11.3 使用Spring实现AOP【重点】使用AOP织入，需要导入一个依赖包！ &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 方式1：通过 Spring API 实现【主要SpringAPI接口实现】首先编写我们的业务接口和实现类 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } public class UserServiceImpl implements UserService { public void add() { System.out.println(&quot;增加了一个用户&quot;); } public void delete() { System.out.println(&quot;删除了一个用户&quot;); } public void update() { System.out.println(&quot;修改了一个用户&quot;); } public void query() { System.out.println(&quot;查询了一个用户&quot;); } } &lt;!--applicationContext.xml配置--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kerr.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kerr.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.kerr.log.AfterLog&quot;/&gt; &lt;!--方式一：使用原生Spring API接口--&gt; &lt;!--导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点: expression：表达式；execution(要执行的位置)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kerr.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加--&gt; &lt;!--把log、afterLog切到pointcut中执行--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试类 public class MyTest { public static void main(String[] args) { // 获取容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 动态代理代理的是接口，因此参数写的是接口 // 得到对象 UserService userService =context.getBean(&quot;userService&quot;,UserService.class); // 使用对象方法 userService.add(); } } 输出结果： 方式2：自定义类实现AOP【主要是切面定义】1.来一个自定义切入点类： package com.kerr.diy; public class DiyPointCut { public void before() { System.out.println(&quot;方法执行前&quot;); } public void after() { System.out.println(&quot;方法执行后&quot;); } } 2.配置xml中的aop &lt;aop:config&gt; &lt;!--自定义切面，ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点：com.kerr.service.UserServiceImpl，在指责格类中，实现下面的通知--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kerr.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 3.测试类 public class MyTest { public static void main(String[] args) { // 获取容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 动态代理代理的是接口，因此参数写的是接口 // 得到对象 UserService userService =context.getBean(&quot;userService&quot;,UserService.class); // 使用对象方法 userService.add(); } } 4.输出 方式3：基于注解实现AOPapplicationContext.xml文件： &lt;!-- applicationContext.xml --&gt; &lt;!-- 注解使用 --&gt; &lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.kerr.diy.AnnotationPointCut&quot;/&gt; &lt;!-- 开启注解支持 --&gt; &lt;aop:aspectj-autoproxy/&gt; 注解切入点文件： /** * 使用注解方式实现aop */ @Aspect // 标注这个类是一个切面 public class AnnotationPointCut { @Before(&quot;execution(* com.kerr.service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;方法执行前...&quot;); } @After(&quot;execution(* com.kerr.service.UserServiceImpl.*(..))&quot;) public void after(){ System.out.println(&quot;方法执行后...&quot;); } // 在环绕增强中，我们可以给定一个参数，代表我们要处理切入的点 @Around(&quot;execution(* com.kerr.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;环绕前&quot;); Signature signature = jp.getSignature();// 获得签名 System.out.println(signature); // 执行方法 Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); } } 3.测试类 public class MyTest { public static void main(String[] args) { // 获取容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 动态代理代理的是接口，因此参数写的是接口 // 得到对象 UserService userService =context.getBean(&quot;userService&quot;,UserService.class); // 使用对象方法 userService.add(); } } 4.输出 12.整合Mybatis中文文档http://mybatis.org/spring/zh/index.html 步骤： 导入相关jar包 mybatis mysql数据库 spring相关的 aop织入 mybatis-spring 编写配置文件 测试 12.1 回忆Mybatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 12.2 Mybatis-spring 编写数据源 SqlSessionFactory sqlSessionTemplate 需要给接口加实现类【实现类里做原来mybatis做的事情】 将实现类注入到Spring中 测试 `xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!--1.编写数据源DataSource：使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!--2.sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kerr/mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--3.sqlSessionTemplate就是我们使用的SqlSession--&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能使用构造方法注入SqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--5.将实现类注入到Spring中--&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;com.kerr.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt; ```java // 4.实现类 import java.util.List; public class UserMapperImpl implements UserMapper{ // 原来，我们的所有操作都是用sqlSession来执行；现在，都使用sqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } // 测试 public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } } 官方文档分析：SqlSessionFactoryBean 要创建 bean工厂，首先把sqlSessionFactory放进去，由于放sqlSessionFactory需要一个dataSource，所以还需要连一个dataSource。 使用SqlSessionhttp://mybatis.org/spring/zh/sqlsession.html#SqlSessionTemplate 13.声明式事务 回顾事务 把一组业务当成一个业务来做，要么都成功，要么都失败！ 事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎！ 确保完整性和一致性。 事务的ACID原则： 原子性：确保一组业务要么都成功，要么都失败。 一致性：一旦事务完成，要么都被提交，要么都不提交，要保持资源和状态的一致性。 隔离性：事务和事务之间互相不干扰，防止数据损坏。 持久性：事物一旦完成了，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中。 Spring中的事务管理 声明式事务：AOP 编程式事务：需要在代码中进行事务的管理（try…catch）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：Spring","slug":"JavaEE开发框架：Spring","permalink":"/tags/JavaEE开发框架：Spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring笔记（上）","slug":"Spring学习笔记（上）","date":"2020-10-29T15:36:25.000Z","updated":"2020-11-04T08:34:48.980Z","comments":true,"path":"2020/10/29/Spring学习笔记（上）/","link":"","permalink":"/2020/10/29/Spring学习笔记（上）/","excerpt":"","text":"Spring5.2.0（上）spring中文文档https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans官方文档https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace1、创建spring工程 具体如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kerr&lt;/groupId&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;spring-01-ioc1&lt;/module&gt; &lt;module&gt;spring-02-hellospring&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2、 创建与配置spring子模块（module） 因为spring子工程继承了初始项目project的pom，因此不需要进一步配置子工程的pom，只需要建立spring相应的工程文件即可： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kerr&lt;/groupId&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;spring-01-ioc1&lt;/module&gt; &lt;module&gt;spring-02-hellospring&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; spring工程实践—— 对应代码： // Hello.java package com.kerr.pojo; public class Hello { private String str; @Override public String toString() { return &quot;Hello{&quot; + &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; + &#39;}&#39;; } public void setStr(String str) { this.str = str; } public String getStr() { return str; } } &lt;!--bean.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 使用spring来创建对象，在spring这些都称为Bean Java写法： 类型 变量名 = new 类型； Hello hello = new Hello(); spring内部： bean = 对象 new Hello(); id = 变量名 class = 全路径（要new的对象） property 相当于给对象的属性设置一个值！ --&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kerr.pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; // MyTest.java import com.kerr.dao.UserDaoMysqlImpl; import com.kerr.dao.UserDaoOracleImpl; import com.kerr.service.UserService; import com.kerr.service.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { // 用户实际调用的是业务层，dao层不需要接触 /** * 传统new对象的方式 */ // UserService userService = new UserServiceImpl(); // // ((UserServiceImpl) userService).setUserDao(new UserDaoOracleImpl()); // userService.getUser(); /** * spring创建对象方式 */ // 获取ApplicationContext；拿到spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 容器在手，天下我有，需要什么，就get什么 UserServiceImpl userServiceImpl =(UserServiceImpl) context.getBean(&quot;UserServiceImpl&quot;); userServiceImpl.getUser(); } } 值得一提的是，spring创建实例对象的方法是通过控制set方法来创建的，这是IOC的原理。 MyTest.java文件中，ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);说明ClassPathXmlApplicationContext与ApplicationContext有着千丝万缕的关系。下面通过源码的方式获取这些继承和实现关系。 可见，从ClassPathXmlApplicationContext到ApplicationContext总共6层关系，前5层是都是继承，最后是实现接口。（此时此刻我又想起了那句经典：你看到的我在第二层，而你把我想成了第一层，实际上我在第五层~~） ok，从现在开始，我们彻底不用在程序中去改动了，要实现不同操作，只需要在xml配置文件中修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配！实际上，spring容器相当于一个婚恋网站，当网站开始的时候，内部的所有人都注册（实例化）好了，想要找哪一个直接get就好了。也就是说，所有bean注册好之后就已经被spring实例化了。 3、spring工作原理分析 ApplicationContext接口下读取配置的方法： ｛% asset_img ApplicationContext接口下读取配置的方法.png %｝ 4、 IoC创建对象的方式 使用无参构造创建对象，默认！ &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;&gt; &lt;!-- 默认无参构造创建对象的方法：name指的是实体类中的属性名，Kerr是传入的属性值 --&gt; &lt;property name=&quot;name&quot; value=&quot;Kerr&quot;/&gt; &lt;/bean&gt; 使用有参构造方法创建对象： 下标赋值 &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;&gt; &lt;!-- 有参构造创建对象的方法1：下标法（index中传入输入参数对应的索引号，value传入属性值） --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;Kerr&quot;/&gt; &lt;/bean&gt; 类型（不建议使用，因为当第一个和第二个参数都为相同类型时，无法使用） &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;&gt; &lt;!-- 有参构造创建对象的方法2：参数类型（不建议使用） --&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Kerr&quot;/&gt; &lt;/bean&gt; 参数名（重点掌握（这个就够用了！！！）） &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot;&gt; &lt;!-- 通过参数名来设置 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Kerr&quot;/&gt; &lt;/bean&gt; 总结：在配置文件加载的时候，容器（ApplicationContext）（spring中的bean是在容器中的）中管理的对象就已经初始化了。 5、 spring配置分析5.1 别名（alias）&lt;!-- name表示要创建的对象名，alias表示对应对象名的别名。给对象添加别名，如果User太多了，可以起别名。通过别名也可以获取到这个对象 --&gt; &lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt; 5.2 Bean的配置&lt;!-- id：bean的唯一标识符，也就是要创建的对象名 class：bean对象所对应的全限定名，包名+类名 name：也是别名，而且name更高级，可以同时取多个别名（逗号、空格、分号等分隔都可以） --&gt; &lt;bean id=&quot;userT&quot; class=&quot;com.kerr.pojo.UserT&quot; name=&quot;user2,u2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Kerr&quot;/&gt; &lt;property name=&quot;uid&quot; value=&quot;123&quot;/&gt; &lt;/bean&gt; 5.3 import这个import，一般用于团队开发使用，可以将多个配置文件，导入合并为一个。 假设，现在项目中有多个人开发，这三个人利用不同的beans.xml配置，最后汇总需要用import将所用人的beans.xml合并为一个总的。 P1、beans.xml P2、beans2.xml P3、beans3.xml 总：applicationContext.xml &lt;import resource=&quot;beans.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;import resource=&quot;beans3.xml&quot;/&gt; 使用的时候，直接使用总的配置就可以了。 6、依赖注入6.1 构造器注入（前面已经记录过）6.2 Set方式注入（重点） 依赖注入：Set注入 依赖：bean对象的创建依赖于容器 注入：bean对象中的所用属性，由容器来注入 例子： 例子的结构｛% asset_img 依赖注入的项目结构.png %｝ 下面是本例中的代码： package com.kerr.pojo; // 实体类Student import java.util.*; public class Student { private String name; // 通过value赋值 private Address address; // 通过ref赋值 private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; // 空指针 private Properties info; @Override public String toString() { return &quot;Student{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, address=&quot; + address + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbys=&quot; + hobbys + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, wife=&#39;&quot; + wife + &#39;\\&#39;&#39; + &quot;, info=&quot; + info + &#39;}&#39;; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String[] getBooks() { return books; } public void setBooks(String[] books) { this.books = books; } public List&lt;String&gt; getHobbys() { return hobbys; } public void setHobbys(List&lt;String&gt; hobbys) { this.hobbys = hobbys; } public Map&lt;String, String&gt; getCard() { return card; } public void setCard(Map&lt;String, String&gt; card) { this.card = card; } public Set&lt;String&gt; getGames() { return games; } public void setGames(Set&lt;String&gt; games) { this.games = games; } public String getWife() { return wife; } public void setWife(String wife) { this.wife = wife; } public Properties getInfo() { return info; } public void setInfo(Properties info) { this.info = info; } } package com.kerr.pojo; // 实体类Address public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return &quot;Address{&quot; + &quot;address=&#39;&quot; + address + &#39;\\&#39;&#39; + &#39;}&#39;; } } &lt;!--set依赖注入--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.kerr.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;北京&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.kerr.pojo.Student&quot;&gt; &lt;!--第1种：普通值注入：value--&gt; &lt;property name=&quot;name&quot; value=&quot;Kerr&quot;/&gt; &lt;!--第2种：bean注入：ref--&gt; &lt;!--此处，由于address也是一个bean，所以先给他定义bean--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--数组注入：ref--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list--&gt; &lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;value&gt;敲看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;!--entry：实体--&gt; &lt;entry key=&quot;身份证&quot; value=&quot;1564312531214531&quot;/&gt; &lt;entry key=&quot;学生证&quot; value=&quot;14213212&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null注入--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--配置文件/属性类注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;姓名&quot;&gt;Kerr&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;学号&quot;&gt;789456123&lt;/prop&gt; &lt;prop key=&quot;学院&quot;&gt;计算机学院&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; import com.kerr.pojo.Student; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; // 测试类 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student =(Student) context.getBean(&quot;student&quot;); System.out.println(student.toString()); // 输出结果 /* Student{ name=&#39;Kerr&#39;, address=Address{address=&#39;北京&#39;}, books=[红楼梦, 水浒传, 西游记, 三国演义], hobbys=[听歌, 敲代码, 敲看电影], card={身份证=1564312531214531, 学生证=14213212}, games=[LOL, COC, BOB], wife=&#39;null&#39;, info={学号=789456123, 性别=男, 学院=计算机学院, 姓名=Kerr} } */ } } 6.3 扩展方式注入（p、c命名空间注入）我们可以使用p命令和c命令来实现注入 ｛% asset_img pc命名空间注入法.png %｝ 首先在userbeans.xml文件的标签中加入以下约束 &lt;!--p命名空间--&gt; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;!--c命名空间--&gt; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 具体userbeans.xml文件内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot; p:name=&quot;Kerr&quot; p:age=&quot;18&quot;/&gt; &lt;!--c命名空间注入，通过构造器注入:construct-args（构造器参数）--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.kerr.pojo.User&quot; c:name=&quot;Kerr2&quot; c:age=&quot;28&quot;/&gt; &lt;/beans&gt; 测试： @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;); User user20 = (User) context.getBean(&quot;user2&quot;); // 可以强转 User user21 = context.getBean(&quot;user2&quot;, User.class); // 可以在参数指定映射的类，就不需要强转了，会自动识别出返回的类 System.out.println(user20); System.out.println(user21); } /** 输出： User{name=&#39;Kerr2&#39;, age=28} User{name=&#39;Kerr2&#39;, age=28} */ 注意点：p和c命名空间不能直接使用，需要导入xml约束，官网文档也有。 6.4 Bean Scope（bean作用域）｛% asset_img Bean作用域.png %｝ 单例模式（Spring默认机制：默认只有一个对象）存在问题：并发访问情况下会产生延迟或者数据不一致问题！！！因此一般用在单线程中！ &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot; p:name=&quot;Kerr&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt; 原型模式（每次从容器中get的时候，都会产生一个新对象）存在问题：浪费资源！！！一般用在多线程中！ &lt;bean id=&quot;user&quot; class=&quot;com.kerr.pojo.User&quot; p:name=&quot;Kerr&quot; p:age=&quot;18&quot; scope=&quot;prototype&quot;/&gt; 其余的request、session、application这些只能在web开发中使用。 7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式！ Spring会在上下文中自动寻找，并自动给bean装配属性！ 在Spring中有三种装配方式： 在xml中显式的配置 在java中显式配置 隐式的自动装配bean【重要！！！】 7.1 自动装配——测试环境搭建 一个人People有两个宠物Cat、Dog &lt;bean id=&quot;people&quot; class=&quot;com.kerr.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;主人&quot;/&gt; &lt;!--传统配置方式，直接将属性赋值给对象--&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;/bean&gt; 7.2 ByName自动装配（只适用于id唯一）&lt;!-- autowire=&quot;byName&quot;的原理：会自动在容器上下文中查找和自己对象set方法后面的值（set后紧跟的那个单词比如setDog-&gt;dog）对应的bean id。 --&gt; &lt;bean id=&quot;people&quot; class=&quot;com.kerr.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;主人&quot;/&gt; &lt;/bean&gt; 7.3 ByType自动装配（只适用于类型唯一）&lt;!-- autowire=&quot;byType&quot;的原理：会自动在容器上下文中查找和自己对象属性相同的bean。 --&gt; &lt;bean id=&quot;people&quot; class=&quot;com.kerr.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;主人&quot;/&gt; &lt;/bean&gt; 小结： byName的时候需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致； byType的时候需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致； 7.4 使用注解实现自动装配jdk1.5开始支持注解，spring2.5就有了。 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” 要使用注解须知： 导入约束context：下面代码段（行4） ==配置注解的支持（开启注解支持）==：context:annotation-config/ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; ==7.4.1 @Autowired== 直接在属性上使用即可（注解利用反射实现的，因此使用注解开发set方法也可以不要） 使用@Autowired就可以不用编写set方法了，前提是你这个自动装配的属性在IoC（Spring）容器中存在，且符合名字byName！ 科普： @Nullable 字段标记了这个注解，说明这个字段可以为null； public People(@Nullable String name) { this.name = name; } @Autowired下唯一属性required的作用：标记字段可为null，为null时不报错 public @interface Autowired { boolean required() default true; } @Autowired下唯一属性required的测试代码 public class People { // 如果显式定义Autowired的required属性为null，说明这个对象可以为null，否则不允许为空 @Autowired(required = false) public Cat cat; @Autowired public Dog dog; public String name; } 7.4.2 @Autowired的特殊情况​ 假如bean中相同对象Cat的id有多个，类型也不唯一，而且没有对应的默认的正确id，首先会使用byType查找，如果存在多个类型相同的，再通过byName。那么测试类会报错：找不到对应的类的正确名字。此时需要另一个注解@Qualifier(value = &quot;对象名&quot;)去指定其中一个bean id来正确使用bean的这些配置。（但凡满足唯一类型或者能找到默认正确id都不会报错！！！） ​ ==如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value = “对象名”)去配置@Autowired的使用，指定一个唯一的bean对象注入。== &lt;!--假如bean中相同对象Cat的id有多个，而且没有对应的默认的正确id，那么测试类会报错：找不到对应的类的正确名字。此时需要另一个注解@Qualifier(value = &quot;对象名&quot;)去指定其中一个bean id来正确使用bean的这些配置--&gt; &lt;bean id=&quot;cat11&quot; class=&quot;com.kerr.pojo.Cat&quot;/&gt; &lt;bean id=&quot;cat111&quot; class=&quot;com.kerr.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog22&quot; class=&quot;com.kerr.pojo.Dog&quot;/&gt; &lt;bean id=&quot;dog222&quot; class=&quot;com.kerr.pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;com.kerr.pojo.People&quot;/&gt; // 测试类 public class People { @Autowired @Qualifier(value = &quot;cat11&quot;) public Cat cat; @Autowired @Qualifier(value = &quot;dog222&quot;) public Dog dog; public String name; } 7.4.3 关于@Resource注解 @Resource是属于java的注解，功能同@Autowired类似，但是效率比@Autowired略低，如果用@Resource解决上述7.4.2问题的话，需要更改为如下测试类： public class People { @Resource(name = &quot;cat11&quot;) public Cat cat; @Resource(name = &quot;dog222&quot;) public Dog dog; public String name; } 不过，开发中更常用@Autowired。 7.4.4 小结（@Resource和@Autowired的相同点和不同点） 相同点： 都是用来自动装配的，都可以放在属性字段上 不同点： @Autowired默认会使用byType查找，如果存在多个类型相同的，不能唯一自动装配上属性，再通过byName（此处需要配合@Qualifier(value = “bean的id”)使用）进行匹配，再不行则报错 @Resource默认会使用byName装配，如果不存在正确名称，再通过byType，再不行则报错 执行顺序不同","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：Spring","slug":"JavaEE开发框架：Spring","permalink":"/tags/JavaEE开发框架：Spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从URL到页面解析从URL到页面解析","slug":"从输入URL到页面解析完成的过程","date":"2020-10-28T14:54:05.000Z","updated":"2020-10-28T14:56:37.745Z","comments":true,"path":"2020/10/28/从输入URL到页面解析完成的过程/","link":"","permalink":"/2020/10/28/从输入URL到页面解析完成的过程/","excerpt":"","text":"过程概述js html是基于http在浏览器和服务器之间进行传输（是响应的第四部分的字符串）1.http协议基于TCP/IP协议过程：浏览器输入域名-&gt;浏览器查询dns是否有缓存-&gt;DNS查询到域名-&gt;TCP/IP链接（三次握手）-&gt;建立连接-&gt;浏览器发出请求-&gt;服务器响应（1.2.3.4）-&gt;浏览器会先获得响应头然后在获得相应体（因为响应体有时候会很大）. *1、浏览器地址栏输入url* *2、浏览器会先查看浏览器缓存*--*系统缓存*--*路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步* *3、域名解析（DNS）获取相应的ip* *4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手* *5、握手成功，浏览器向服务器发送http请求，请求数据包* *6、服务器请求数据，将数据返回到浏览器* *7、浏览器接收响应，读取页面内容，解析html源码，生成DOm树* *8、解析css样式、浏览器渲染，js交互绑定多个域名，数量不限* 三次握手知道了服务器的 IP 地址，下面便开始与服务器建立连接了。 通俗地讲，通信连接的建立需要经历以下三个过程： 主机向服务器发送一个建立连接的请求（您好，我想认识您）； 服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。 *补充说明 TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。 网页请求与显示当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ； 四次挥手主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； *补充说明 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"页面解析过程","slug":"页面解析过程","permalink":"/tags/页面解析过程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mybatis的“的增删改查","slug":"Mybatis02","date":"2020-10-23T13:58:00.000Z","updated":"2020-10-23T14:01:52.808Z","comments":true,"path":"2020/10/23/Mybatis02/","link":"","permalink":"/2020/10/23/Mybatis02/","excerpt":"","text":"namespace 将上面案例中的UserMapper接口改名为 UserDao； 将UserMapper.xml中的namespace改为为UserDao的路径 . 再次测试 结论： 配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！ select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType 需求：根据id查询用户 1、在UserMapper中添加对应方法 public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id); } 2、在UserMapper.xml中添加Select语句 &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; 3、测试类中测试 @Test public void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 课堂练习：根据 密码 和 名字 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 //通过密码和名字查询用户 User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd); /* &lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; */ 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map &lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;username&quot;,&quot;小明&quot;); map.put(&quot;pwd&quot;,&quot;123456&quot;); User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 insert 我们一般使用insert标签进行插入操作，它的配置和select标签差不多！ 需求：给数据库增加一个用户 1、在UserMapper接口中添加对应的方法 //添加一个用户 int addUser(User user); 2、在UserMapper.xml中添加insert语句 &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; 3、测试 @Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;); int i = mapper.addUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } 注意点：增、删、改操作需要提交事务！ update 我们一般使用update标签进行更新操作，它的配置和select标签差不多！ 需求：修改用户的信息 1、同理，编写接口方法 //修改一个用户 int updateUser(User user); 2、编写对应的配置文件SQL &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update user set name=#{name},pwd=#{pwd} where id = #{id} &lt;/update&gt; 3、测试 @Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); user.setPwd(&quot;asdfgh&quot;); int i = mapper.updateUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } delete 我们一般使用delete标签进行删除操作，它的配置和select标签差不多！ 需求：根据id删除一个用户 1、同理，编写接口方法 //根据id删除用户 int deleteUser(int id); 2、编写对应的配置文件SQL &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #{id} &lt;/delete&gt; 3、测试 @Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(5); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close(); } 小结： 所有的增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"/tags/Mybatis框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mybatis01","slug":"Mybatis01","date":"2020-10-23T13:50:44.000Z","updated":"2020-10-26T07:44:52.710Z","comments":true,"path":"2020/10/23/Mybatis01/","link":"","permalink":"/2020/10/23/Mybatis01/","excerpt":"","text":"Mybatis创建和初始化流程​```flow st=&gt;start: 打开idea op1=&gt;operation: 1.创建maven项目，删除src目录 op2=&gt;operation: 2.连接数据库 op3=&gt;operation: 3.导入jar包（mysql、mybatis） op4=&gt;operation: 4.创建Mybatis工具类（工具类需要一个配置文件，去resources里写一个配置文件mybatis-config.xml），获取sqlSessionFactory工厂，得到sqlSession op5=&gt;operation: 5.编辑配置文件mybatis-config.xml，环境准备 op6=&gt;operation: 6.写User实体类和UserDao接口 op7=&gt;operation: 6.UserMapper.xml代替原来的UserDao实现类 op8=&gt;operation: 6.测试：获得sqlSession对象，然后调用getMapper方法执行sql获得结果集 e=&gt;end st(bottom)-&gt;op1(bottom)-&gt;op2(bottom)-&gt;op3(bottom)-&gt;op4(bottom)-&gt;op5(bottom)-&gt;op6(bottom)-&gt;op7(bottom)-&gt;op8(bottom)-&gt;e ​ &gt; 环境说明： - jdk 8 + - MySQL 5.7.19 - maven-3.6.1 - IDEA 学习前需要掌握： - JDBC - MySQL - Java 基础 - Maven - Junit &gt; 什么是MyBatis - MyBatis 是一款优秀的**持久层框架** - MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 - MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 - MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 - 2013年11月迁移到**Github** . - Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html - GitHub : https://github.com/mybatis/mybatis-3 &gt; 持久化 **持久化是将程序数据在持久状态和瞬时状态间转换的机制。** - 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 - JDBC就是一种持久化机制。文件IO也是一种持久化机制。 - 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 **为什么需要持久化服务呢？那是由于内存本身的缺陷引起的** - 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 - 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 &gt; 持久层 **什么是持久层？** - 完成持久化工作的代码块 . ----&gt; dao层 【DAO (Data Access Object) 数据访问对象】 - 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种**关系数据库**来完成。 - 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. - 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 &gt; 为什么需要Mybatis - Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . - 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等... , 通过框架可以减少重复代码,提高开发效率 . - MyBatis 是一个半自动化的**ORM框架 (Object Relationship Mapping) --&gt;对象关系映射** - 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！**技术没有高低之分，只有使用这个技术的人有高低之别** - MyBatis的优点 - - 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 - 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 - 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 - 提供xml标签，支持编写动态sql。 - ....... - 最重要的一点，使用的人多！公司需要！ MyBatis第一个程序 **思路流程：搭建环境--&gt;导入Mybatis---&gt;编写代码---&gt;测试** &gt; 代码演示 1、搭建实验数据库 ```sql CREATE DATABASE `mybatis`; USE `mybatis`; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;); 2、导入MyBatis相关 jar 包 GitHub上找 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; 3、编写MyBatis核心配置文件 查看帮助文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4、编写MyBatis工具类 查看帮助文档 import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //获取SqlSession连接 public static SqlSession getSession(){ return sqlSessionFactory.openSession(); } } 5、创建实体类 public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString() } 6、编写Mapper接口类 import com.kuang.pojo.User; import java.util.List; public interface UserMapper { List&lt;User&gt; selectUser(); } 7、编写Mapper.xml配置文件 namespace 十分重要，不能写错！ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 8、编写测试类 Junit 包测试 public class MyTest { @Test public void selectUser() { SqlSession session = MybatisUtils.getSession(); //方法一: //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;); //方法二: UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); } } 9、运行测试，成功的查询出来的我们的数据，ok！ 问题说明 可能出现问题说明：Maven静态资源过滤问题 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"/tags/Mybatis框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"招商金科一面总结","slug":"招商金科一面总结","date":"2020-10-21T08:25:12.000Z","updated":"2020-10-21T08:25:28.654Z","comments":true,"path":"2020/10/21/招商金科一面总结/","link":"","permalink":"/2020/10/21/招商金科一面总结/","excerpt":"","text":"招商金科一面1. 从浏览器输入url到客户端响应的过程2. Spring的注解如何调用的方法3. ArrayList动态扩容机制4. 反射能用来干嘛5. 12306抢票怎么用户实现能抢到又能性能高6. 线程池是怎么实现复用的7. SQL实现多表查询怎么优化8. 怎么理解树的度和阶9. 了解哪些协议？TCP/UDP/HTTP/HTTPS，tcp协议的滑动窗口是用来干嘛的，怎么实现的10. 对检测冲突的协议有了解吗11.对前端（Vue、jQuery）的了解","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"面试","slug":"面试","permalink":"/tags/面试/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"项目一：旅游网站功能实现思路","slug":"项目一：旅游网站功能实现思路","date":"2020-10-20T13:13:28.000Z","updated":"2020-10-20T13:31:16.740Z","comments":true,"path":"2020/10/20/项目一：旅游网站功能实现思路/","link":"","permalink":"/2020/10/20/项目一：旅游网站功能实现思路/","excerpt":"","text":"1. 技术选型1.1 Web层a) Servlet：前端控制器 b) html：视图 c) Filter：过滤器 d) BeanUtils：数据封装 e) Jackson：json序列化工具 1.2 Service层f) Javamail：java发送邮件工具 g) Redis：nosql内存数据库 h) Jedis：java的redis客户端 1.3 Dao层i) Mysql：数据库 j) Druid：数据库连接池 k) JdbcTemplate：jdbc的工具 2. 注册功能的实现思路 3. 登录功能 4. 退出功能 什么叫做登录了？session中有user对象。 实现步骤： 访问servlet，将session销毁 跳转到登录页面 5. 优化Servlet减少Servlet的数量，现在是一个功能一个Servlet，将其优化为一个模块一个Servlet，相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。 6.分类数据展示6.1 分类数据展示（初级） 6.2 对分类数据进行缓存优化分析发现，分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，而且分类的数据不会经常产生变化，所有可以使用redis来缓存这个数据。 7. 根据id查询不同类别的旅游线路数据 8. 旅游线路名称查询9. 旅游线路的详情展示 10. 旅游线路收藏功能 11. 点击按钮收藏线路","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发，项目","slug":"JavaEE开发，项目","permalink":"/tags/JavaEE开发，项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"idea&VS_Code&Shell&Linux命令","slug":"idea&VS_Code&Shell&Linux命令","date":"2020-10-13T12:29:13.000Z","updated":"2020-10-13T12:34:26.878Z","comments":true,"path":"2020/10/13/idea&VS_Code&Shell&Linux命令/","link":"","permalink":"/2020/10/13/idea&VS_Code&Shell&Linux命令/","excerpt":"","text":"idea1. 快速生成变量： Ctrl + Alt + V或者.var 2. 格式化代码： Ctrl + Alt + L 3. try catch异常处理&amp;导包 Alt + Enter 4. 注释： Ctrl + / 单行 Ctrl + shift + / 多行 5. iter迭代器 键入iter 6. foreach（增强for） 数组或者集合名.for 7. 复制上一行内容到下一行 Ctrl + D 8. 多行操作 Alt + 鼠标左键 9. 任意移动一行（也可选中多行进行操作） Shift + Alt + 上/下键 10. 参数提示 Ctrl + P 11. 选中多行代码try...catch 选中+Ctrl+alt+t 12. 向上插入新的一行并且将光标移动到行首 Ctrl+Alt+Enter 13. 向下插入新的一行并且将光标移动到行首 Shift+Enter 14. 快速从接口到实现类 Ctrl+Alt+左键 VS code1. 内嵌实时渲染浏览器 Ctrl + Shift + V 2. 命令面部 Ctrl + Shift + P 3. 多行操作 Alt + Shift + 鼠标左键 相对路径： ./ : 代表当前目录 ../: 代表上一级目录 DOS命令netstat -ano：查看端口号 (ps：PID是进程ID) Linux（CentOS）命令1. ipconfig : 查询ip 2. ll : 列出当前目录详细列表 （后加 -a为显示隐藏文件） 3. ls : 列出当前目录文件（夹）（后加 -a为显示隐藏文件） 4. mkdir : 创建目录 5. rmdir : 删除目录 6. cd : 进入目录","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"/tags/快捷键/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SpringBoot重要笔记","slug":"SpringBoot重要笔记","date":"2020-10-06T00:53:17.000Z","updated":"2020-10-07T15:12:26.600Z","comments":true,"path":"2020/10/06/SpringBoot重要笔记/","link":"","permalink":"/2020/10/06/SpringBoot重要笔记/","excerpt":"","text":"1. 创建SpringBoot项目3种方法： 官方渠道：使用Spring Initializr在线创建并导入idea地址：http://start.spring.io/ 基于idea集成的Spring Initializr（脚手架工具） 基于idea创建maven项目并向pom文件中添加配置、依赖和 插件，使之成文标准SB项目的配置文件结构。一般情况下需要添加的配置有： 2. 启动类 Spring Boot 的启动类的作用是启动Spring Boot 项目，是基于Main 方法来运行的。注意：启动类在启动时会做注解扫描(@Controller、@Service、@Repository……)，扫描位置为同包或者子包下的注解，所以启动类的位置应放于包的根下。 创建启动类一般命名为“项目名+Application ”，然后添加main方法： 注意2点： 添加@SpringBootApplication注解； 在main方法中调用SpringApplication类下的静态方法run， SpringApplication.run(SpringBootDemo1Application.class, args); 有2个参数，分别为“启动类名”和“args”。 3. 启动器 Spring Boot 将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景，在jar 包管理上非常方便，最终实现一站式开发。 4. 配置文件 Spring Boot 提供一个名称为application 的全局配置文件，支持两种格式properteis 格式与YAML 格式。 4.1 Properties格式配置Tomcat监听端口 在resources下（创建）打开application.properties文件，k-v是server.port = 8888，具体如下： 此外，数据源配置，数据库链接信息配置都需要放到这个配置文件中。 4.2 YAML格式YAML 格式配置文件的扩展名可以是yaml 或者yml。 4.2.1基本格式要求 大小写敏感 使用缩进代表层级关系 相同的部分只出现一次 4.3 配置文件的存放与加载4.3.1存放位置 当前项目的根目录（或此目录下的/config目录） 当前项目resources目录（或此目录下的/config目录） 4.3.2 不同格式的加载顺序如果同一个目录下，同时存在application.yml和application.properties，默认先读取application.properties，同一个配置属性，在多个文件中配置，默认使用第一个读取到的，后面读取的不覆盖。 4.3.3 不同位置的加载顺序（加载优先级顺序） 当前项目根目录下的/config子目录中（最高）config/application.propertiesconfig/application.yml 当前项目根目录中(其次)application.propertiesapplication.yml 项目的resources 即classpath 根路径下的/config 目录中(一般)resources/config/application.propertiesresources/config/application.yml 项目的resources 即classpath 根路径中(最后)resources/application.propertiesresources/application.yml $\\color{red}{总结：外层优先即根目录/config优先，p优先（p、y字母顺序）}$ 4.4 配置文件中的占位符4.4.1 语法：${}4.4.2占位符作用 “${}”中可以获取框架提供的方法中的值如：random.int 等。 占位符可以获取配置文件中的键的值赋给另一个键作为值。 4.4.3生成随机数 ${random.value} - 类似uuid 的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200 范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10 以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 5. SpringBoot的核心注解5.1@SpringBootApplication是SpringBoot 的启动类。此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。 5.2@SpringBootConfiguration@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是springboot的注解，而@Configuration 是spring 的注解 5.3@Configuration通过对bean 对象的操作替代spring 中xml 文件 5.4@EnableAutoConfigurationSpring Boot 自动配置（auto-configuration）：尝试根据你添加的jar 依赖自动配置你的Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)注解的组合。 5.5@AutoConfigurationPackage@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类（@Controller，@Service 等），以及配置类（@Configuration） 5.6@Import({AutoConfigurationImportSelector.class})直接导入普通的类导入实现了ImportSelector 接口的类导入实现了ImportBeanDefinitionRegistrar 接口的类 5.7@ComponentScan组件扫描，可自动发现和装配一些Bean。 5.8@ConfigurationPropertiesScan@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作用是使用@ConfigurationProperties 注解的类生效。 6. 在项目中创建Controllerpackage com.kerr.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * 处理请求Controller */ @RestController // @Controller+@ResponseBody 直接返回字符串/json串 public class Demo1Controller { @RequestMapping(&quot;/helloWorld&quot;) public String showHelloWorld(){ return &quot;HelloWorld&quot;; } } 6.1Spring Boot 在Controller 中常用注解6.1.1 @RestController@RestController 相当于@Controller+@ResponseBody 注解如果使用@RestController 注解Controller 中的方法无法返回页面，相当于在方法上面自动加了@ResponseBody 注解， 所以没办法跳转并传输数据到另一个页面， 所以InternalResourceViewResolver 也不起作用，返回的内容就是Return 里的内容。 6.1.2 @GetMapping@GetMapping 注解是@RequestMapping(method = RequestMethod.GET)的缩写。 6.1.3 @PostMapping@PostMapping 注解是@RequestMapping(method = RequestMethod.POST)的缩写。 6.1.4 @PutMapping@PutMapping 注解是@RequestMapping(method = RequestMethod.PUT)的缩写。 6.1.5 @DeleteMapping@DeleteMapping 注解是@RequestMapping(method = RequestMethod.DELETE)的缩写。 7. SpringBoot整合Web层技术(2种方式)7.1 整合Servlet方式17.1.1 通过注解扫描完成Servlet组件的注册7.1.2 通过方法完成Servlet 组件的注册","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：SpringBoot","slug":"JavaEE开发框架：SpringBoot","permalink":"/tags/JavaEE开发框架：SpringBoot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2020-10-05T07:30:45.000Z","updated":"2020-10-05T07:30:47.356Z","comments":true,"path":"2020/10/05/SpringBoot入门/","link":"","permalink":"/2020/10/05/SpringBoot入门/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaEE开发框架：SpringBoot","slug":"JavaEE开发框架：SpringBoot","permalink":"/tags/JavaEE开发框架：SpringBoot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"端口被占用的解决办法","slug":"端口被占用的解决办法","date":"2020-10-04T08:04:10.000Z","updated":"2020-10-04T08:33:03.458Z","comments":true,"path":"2020/10/04/端口被占用的解决办法/","link":"","permalink":"/2020/10/04/端口被占用的解决办法/","excerpt":"","text":"Q： 可以看到：4000端口被占用了，首先查到是哪个程序占用了该端口，然后杀掉！ A：打开cmd，输入以下命令： netstat -ano|findstr 4000 查询结果如下： 输入以下命令，来关掉被占用的端口： taskkill /t /f /im 11184 终止结果如下： 最后重新运行该端口程序即可。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"操作系统OS","slug":"操作系统OS","permalink":"/tags/操作系统OS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java中各种内部类的区别","slug":"013-Java中各种内部类的区别","date":"2020-10-04T06:18:44.000Z","updated":"2020-11-04T01:53:20.482Z","comments":true,"path":"2020/10/04/013-Java中各种内部类的区别/","link":"","permalink":"/2020/10/04/013-Java中各种内部类的区别/","excerpt":"","text":"1. 写在前面内部类的主要作用如下： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。 java主要有四种内部类：**成员内部类、静态内部类、方法内部类、匿名内部类**。 成员内部类类似普通的成员变量，定义在属性级别，可以访问外部类任何属性。使用时，new 外部类.new 内部类。 静态内部类不允许访问外部类的非静态属性。使用时可以直接new。 方法内部类是定义在方法内部的类，类似方法的局部变量。只在此方法里使用。可以直接new。 匿名内部类是特殊的方法内部类。主要用于实现接口或抽象类，达到单次实现单次使用的目的，少创建一个类文件。使用时 接口（抽象类）名 实例名=new 接口（抽象类）名（）{接口（抽象类）实现}。 2. 详解内部类分类 一.成员内部类 二.静态内部类 三.局部内部类 四.匿名内部类 一.成员内部类 1.位置 在类的内部，与成员变量，方法同级 2.访问权限修饰符 可以设置全部的类型的访问权限修饰符 3.访问外部类的范围 所有外部类属性和方法（包括private修饰的） 4.内部的方法和属性 只能有非静态的方法和属性 5.创建对象 通过创建外部类对象来创建 public class InstanceOutterClass{ private String name; private static int age; public void say(){} public static void main(String[] args){ new InstanceOutterClass().new InstanceInnerClass();//创建成员内部类对象 } public class InstanceInnerClass{} } 二.静态内部类 1.位置 在类的内部，与成员变量，方法同级 2.访问权限修饰符 可以设置全部的类型的访问权限修饰符 3.访问外部类的范围 所有外部类静态属性和方法（包括private修饰的） 4.内部的方法和属性 可以写所有类型的方法和属性 5.创建对象 通过外部类.内部类构造器 public class StaticOutterClass{ private String name; private static int num; public void say(){} public static void main(String[] args){ new StaticOutterClass.StaticInnerClass();//创建静态内部类对象 } public static class StaticInnerClass{} } 三.局部内部类 1.位置 在类的方法内部 2.访问权限修饰符 就像成员中的一个局部变量，没有访问权限修饰符 3.访问外部类的范围 可以访问外部类的成员方法和变量;访问外部方法或外部作用域中的属性是，被访问的属性会被final修饰 4.内部的方法和属性 和方法中的普通属性一样，所以不能有静态方法和属性 5.创建对象 在该方法或作用域内部创建 四.匿名内部类 1.位置 任何地方，但是要依托于类或接口创建 2.访问权限修饰符 没有访问权限修饰符 3.访问外部类的范围 和局部内部类一致 4.创建对象 声明时候就会创建，且声明必须是跟在new 类名()后面 5.内部的方法和属性 和方法中的普通属性一样，所以不能有静态方法和属性 6.注意 匿名内部类除了依托的类或接口之外,不能指定继承或者实现其他类或接口,同时也不能被其他类所继承,因为没有名字。 匿名内部中,我们不能写出其构造器,因为没有名字。(有无参构造器) 如果依托的是类,那么创建出来的匿名内部类就默认是这个类的子类;如果依托的是接口,那么创建出来的匿名内部类就默认是这个接口的实现类。 如果依托的是类,那么创建出来的匿名内部类就默认是这个类的子类;如果依托的是接口,那么创建出来的匿名内部类就默认是这个接口的实现类。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"012-Hashtable&HashMap&ConcurrentHashMap","slug":"012-Hash","date":"2020-10-04T06:18:44.000Z","updated":"2020-10-04T07:54:41.164Z","comments":true,"path":"2020/10/04/012-Hash/","link":"","permalink":"/2020/10/04/012-Hash/","excerpt":"","text":"附：验证HashMap线程不安全// 验证HashMap线程不安全 /** * 具体做法： * 启动多个线程操作同一个HashMap，不断往里面put * 过一段时间，内部发生死锁 */ public class HashMapTest { public static void main(String[] args) { Mythead mt1 = new Mythead(); Mythead mt2 = new Mythead(); Mythead mt3 = new Mythead(); Mythead mt4 = new Mythead(); Mythead mt5 = new Mythead(); mt1.start(); mt2.start(); mt3.start(); mt4.start(); mt5.start(); } } class Mythead extends Thread { // 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程要做什么？） private static AtomicInteger ai = new AtomicInteger(); // 原子类型 private static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); @Override public void run() { while (ai.get() &lt; 10000000) { map.put(ai.get(), ai.get()); ai.incrementAndGet(); } } } #1，首先，来看看其他几个相关的类 Hashtable是线程安全的，但效率低HashMap是线程不安全的，但效率高Collections.synchronizedMap()，工具类提供了同步包装器的方法，来返回具有线程安全的集合对象性能依然有问题 public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) { return new SynchronizedMap&lt;&gt;(m); } //在这个类的内部方法实现上，也只是单纯加上了锁 public V put(K key, V value) { synchronized (mutex) {return m.put(key, value);} } 为解决这样的矛盾问题，所以JDK提供了并发包，来平衡这样的问题（java.util.concurrent） *2，ConcurrentHashMap（重点） 兼顾了线程安全和效率的问题 分析：HashTable锁了整段数据（用户操作是不同的数据段，依然需要等待）解决方案：把数据分段，执行分段锁（分离锁），核心把锁的范围变小，这样出现并发冲突的概率就变小在保存的时候，计算所存储的数据是属于哪一段，只锁当前这一段 注意：分段锁（分离锁）是JDK1.8之前的一种的方案，JDK1.8之后做了优化。 JDK1.7跟JDK1.8在ConcurrentHashMap的实现上存在以下区别： 1，数据结构JDK1.7采用链表的方式，而JDK1.8则采用链表+红黑树的方式 2，发生hash碰撞之后JDK1.7发生碰撞之后，会采用链表的方式来解决 JDK1.8发生碰撞之后，默认采用链表，但当链表的长度超过8，且数组容量超过64时，会转换为红黑树存储 3，保证并发安全JDK1.7采用分段锁的方式，而JDK1.8采用CAS和synchronized的组合模式 4，查询复杂度JDK1.7采用链表的方式，时间复杂度为O(n)，而JDK1.8在采用红黑树的方式时，时间复杂度为O(log(n)) 题外话： 不过红黑树其实是一种兜底方案，因为当链表数量达到8个的时候，其发生的概率是千万分之几，所以作者考虑到这种极端情况下，需要用红黑树的方式来优化 场景选择","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"011-HashSet的存储原理","slug":"011-HashSet的存储原理","date":"2020-10-04T06:10:39.000Z","updated":"2020-10-04T06:19:36.164Z","comments":true,"path":"2020/10/04/011-HashSet的存储原理/","link":"","permalink":"/2020/10/04/011-HashSet的存储原理/","excerpt":"","text":"HashSet的存储原理或者工作原理，主要是从如何保证唯一性来说起。 这里面主要有3个问题，需要回答？ [x] 第一，为什么要采用Hash算法？有什么优势，解决了什么问题？ [x] 第二，所谓哈希表是一张什么表？ [x] 第三，HashSet如何保证保存对象的唯一性？会经历一个什么样的运算过程？ 首先，我们要明确一点，HashSet底层采用的是HashMap来实现存储，其值作为HashMap的key public boolean add(E e) { return map.put(e, PRESENT)==null; } 具体关于hashmap的细节再说 第一，为什么要采用Hash算法？有什么优势，解决了什么问题？ 解决的问题是唯一性 存储数据，底层采用的是数组 当我们往数组放数据的时候，你如何判断是否唯一？ 可以采用遍历的方式，逐个比较，但是这种效率低，尤其是数据很多的情况下 所以，为了解决这个效率低的问题，我们采用新的方式 采用hash算法，通过计算存储对象的hashcode，然后再跟数组长度-1做位运算，得到我们要存储在数组的哪个下标下，如果此时计算的位置没有其他元素，直接存储，不用比较。 此处，我们只会用到hashCode 但是随着元素的不断添加，就可能出现“哈希冲突”，不同的对象计算出来的hash值是相同的，这个时候，我们就需要比较，才需要用到equals方法 如果equals相同，则不插入，不相等，则形成链表 第二，所谓哈希表是一张什么表？ 本质是一个数组，而且数组的元素是链表 JDK1.7的版本实现 JDK1.8做了优化 随着元素不断添加，链表可能会越来越长，会优化为红黑树","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"010-双向链表中插入元素的具体实现","slug":"010-双向链表中插入元素的具体实现","date":"2020-10-04T02:38:20.000Z","updated":"2020-10-04T02:54:57.999Z","comments":true,"path":"2020/10/04/010-双向链表中插入元素的具体实现/","link":"","permalink":"/2020/10/04/010-双向链表中插入元素的具体实现/","excerpt":"","text":"双向链表是如何插入元素的呢？ 初始条件：A、B分别为链表中的两个相邻节点，A.next为B，B.pre为A； Q：若要在二者之间插入C节点，伪代码如下： C.pre = A; // C的前向指针指向A C.next = A.next; // C的后向指针指向A的后向指针位置 // 此时AB还牵着手，没断开 A.next.pre = C; A.next = C; [x] 图示：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"转载开篇","slug":"转载开篇","date":"2020-10-02T07:54:44.000Z","updated":"2020-10-02T07:58:45.628Z","comments":true,"path":"2020/10/02/转载开篇/","link":"","permalink":"/2020/10/02/转载开篇/","excerpt":"","text":"https://www.bilibili.com/read/cv6490548","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"随想开篇","slug":"随想开篇","date":"2020-10-02T07:48:27.000Z","updated":"2020-10-02T07:50:35.108Z","comments":true,"path":"2020/10/02/随想开篇/","link":"","permalink":"/2020/10/02/随想开篇/","excerpt":"","text":"Hello, world &amp; life.","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"心情","slug":"心情","permalink":"/tags/心情/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"发发的资源","slug":"发发的资源","date":"2020-10-02T07:15:54.000Z","updated":"2020-10-02T07:22:06.672Z","comments":true,"path":"2020/10/02/发发的资源/","link":"","permalink":"/2020/10/02/发发的资源/","excerpt":"","text":"链接：https://pan.baidu.com/s/1MRtmDgWD4lSp6aeRB6y4fw提取码：1mft","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"谈谈ArrayList和LinkedList的区别","slug":"009-谈谈ArrayList和LinkedList的区别","date":"2020-10-02T05:41:02.000Z","updated":"2020-10-02T06:21:44.729Z","comments":true,"path":"2020/10/02/009-谈谈ArrayList和LinkedList的区别/","link":"","permalink":"/2020/10/02/009-谈谈ArrayList和LinkedList的区别/","excerpt":"","text":"1，底层数据结构的差异 ArrayList，数组，连续一块内存空间LinkedList，双向链表，不是连续的内存空间 2，一个常规的结论虽然不严谨，但也可以应付很多面试了 ArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。 3，ArrayList细节分析1，增加 添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容 数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小 怎么扩容？ 当发现容量不够之后，就进行扩容 按原先数组容量的1.5倍进行扩容，通过位运算（效率高），下面是关键的源码 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 再将原先数组的元素复制到新数组，Arrays elementData = Arrays.copyOf(elementData, newCapacity) 添加到其他位置，这个时候需要做整体的搬迁 2，删除 删除末尾，并不需要迁移 删除其他的位置，这个时候也需要搬迁 3，修改 修改之前，必须先定位 定位-查找-ArrayList（数组是一段连续的内存空间，定位会特别快） 4，查找 如上所述 4，LinkedList细节分析1，提供了的两个引用（first，last）2，增加添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的pre，新节点设置为last 我们看下源码： void linkLast(E e) { //获取到最后一个节点 final Node&lt;E&gt; l = last; //构建一个新节点，将当前的last作为这个新节点的pre final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //把last指向新节点 last = newNode; //如果原先没有最后一个节点 if (l == null) //将first指向新节点 first = newNode; else //否则，将原先的last的next指向新节点 l.next = newNode; size++; modCount++; } Node节点的定义：内部类 private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } 添加到其他位置，这个时候，就需要调整前后节点的引用指向 3，如何去定义一个双向链表的节点，如上述的源码所示4，修改修改最后一个节点或者第一个节点，那么就很快（first，last） 修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下： if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } 5，一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，哪个更耗内存，为什么？ 6，LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"008-List和Set的区别","slug":"008-List和Set的区别","date":"2020-10-02T05:35:13.000Z","updated":"2020-10-02T06:16:01.783Z","comments":true,"path":"2020/10/02/008-List和Set的区别/","link":"","permalink":"/2020/10/02/008-List和Set的区别/","excerpt":"","text":"List（有序，可重复）：子类-&gt;ArrayList、LinkedList Set（无序，不可重复）：子类-&gt;HashSet、TreeSet（此无序！=可排序） Collections和Collection的区别： ​ Java里工具类的命名：+s结尾","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"007-方法的重写和重载的区别","slug":"007-方法的重写和重载的区别","date":"2020-10-02T05:29:57.000Z","updated":"2020-10-02T05:32:39.033Z","comments":true,"path":"2020/10/02/007-方法的重写和重载的区别/","link":"","permalink":"/2020/10/02/007-方法的重写和重载的区别/","excerpt":"","text":"重载：发生在一个类里面，方法名相同，参数列表不同（混淆点：跟返回类型没关系） 以下不构成重载public double add(int a,int b)public int add(int a,int b)​ 重写：发生在父类子类之间的，方法名相同，参数列表相同","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"006.Integer和int","slug":"006-Integer和int","date":"2020-10-02T05:22:55.000Z","updated":"2020-10-02T05:29:38.903Z","comments":true,"path":"2020/10/02/006-Integer和int/","link":"","permalink":"/2020/10/02/006-Integer和int/","excerpt":"","text":"public static void main(String[] args){ Integer i1 = new Integer(12); Integer i2 = new Integer(12); System.out.println(i1 == i2); // false Integer i3 = 126; Integer i4 = 126; // 反编译工具 Integer.valueOf(126); int i5 = 126; System.out.println(i3 == i4); // true System.out.println(i3 == i5); // true 自动拆箱，数值 Integer i6 = 128; Integer i7 = 128; int i8 = 128; System.out.println(i6 == i7); // false System.out.println(i6 == i8); // true 自动拆箱，数值 } 第一个sout（sout指的是System.out.println()）中，是两个引用类型比较，比较的是地址，很显然，i1和i2是new出来的，因此占用了两块堆空间，也就是说i1和i2的地址不一样。 第二个：i3和i4是基本类型，都没有new；而左边是Integer类引用类型，因此这种语句有一个装箱操作； 而基本类型赋值给引用类型，需要装箱操作。JDK1.5之后，有自动装箱操作。i3 i4都还在缓存最小值low-128和最大值high127之间，直接用缓存里面的数据，答案是true。如果超出这个范围，需要重新new一个出来，这样的话结果就不一样了。 第三个：当引用类型和基本类型比较时，需要进行自动拆箱，将包装类Integer转换成int型，最后比较的是二者的数值。所以答案是true。 第四个：128已经越界，因此需要new一个出来，那么两个引用类型比较，比较地址，二者分别new，地址肯定不一样。 第五个：同第三个。 结论：1️⃣、引用类型和引用类型比较，需要判断是否越界[-128,127]： 1）不越界：true；因为不需要new； 2）越界：false；因为需要new。 2️⃣、引用类型和基本类型比较，直接看数值，因为引用类型要自 动拆箱，然后再比较。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"记第一次喝吐~~~","slug":"记第一次喝吐","date":"2020-09-28T13:37:34.000Z","updated":"2020-09-28T13:56:26.586Z","comments":true,"path":"2020/09/28/记第一次喝吐/","link":"","permalink":"/2020/09/28/记第一次喝吐/","excerpt":"","text":"2020年9月27日晚九点半左右，为老磊庆生（实际上生日早就过去了好几天~~~）。 ​ 逞能了一把，以为自己白啤配很能喝。。。先喝了一杯啤的润润口，然后蹦起来白的倒满，快速的喝完之后，接着玩起了游戏，没想到竟然大大的输了一把。。。用一个大的喝扎啤的杯子倒了满满一杯（应该一瓶啤酒的量），吨吨吨~喝完之后想撒尿。。。撤硕有yin，就站那等着。我是万万妹想到啊，越站越晕，等里边俩男的出来之后，额不对，没记错的话是三个男的，从一个两平出头的小撤硕出来了。然后我上完撤硕之后回去就不行了，开始出汗，脸色苍白，有了晕车那种感觉。。。就趴那里等其他人玩完游戏回家。​ 十几分钟后，晚宴结束，出了门，老磊付款的时候，我坚持不住，吐院子里了~~~​ 事后，大家对我都特好，又是送水又是问候。。。太温暖了~","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"005.递归必备掌握题目","slug":"005-递归必备掌握题目","date":"2020-09-28T09:07:56.000Z","updated":"2020-09-28T09:12:11.599Z","comments":true,"path":"2020/09/28/005-递归必备掌握题目/","link":"","permalink":"/2020/09/28/005-递归必备掌握题目/","excerpt":"","text":"递归这道算法题一般考查的递归的编程技能，那么我们回顾下递归程序的特点： 1，什么是递归？ 递归，就是方法内部调用方法自身递归的注意事项：找到规律，编写递归公式找到出口（边界值），让递归有结束边界 注意：如果递归太多层，或者没有正确结束递归，则会出现“栈内存溢出Error”！ 问题：为什么会出现栈内存溢出，而不是堆内存溢出？ ​ 因为每次调用的方法是在栈中创建栈帧的空间，而不是堆。 2，这道题该怎么写？ 规律：N!=（n-1）!*n; 出口：n == 1或 n == 0 return 1; /** * 1.n的阶乘 * @param n * @return */ public static int getResult(int n) { if (n &lt; 0) { throw new IllegalArgumentException(&quot;非法参数&quot;); } if (n == 0 || n == 1) { return 1; } return getResult(n - 1) * n; } 3，如何实现递归求斐波那切数列第N个数字的值（传说中的不死神兔就是这个问题） 数字的规律：1,1,2,3,5,8,13,21….（第三个数等于前两个数之和） 所以，我们可以分析编写如下： /** 规律：每个数等于前两个数之和 出口：第一项和第二项都等于1 */ /** * 2. 斐波那契数列（求第n项的值） * @param n * @return */ public static int getFeiBo(int n){ if (n&lt;0){ return -1; } if (n==0 || n==1){ return 1; }else{ return getFeiBo(n-1)+getFeiBo(n-2); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"004.接口和抽象类","slug":"004-接口和抽象类","date":"2020-09-28T09:03:45.000Z","updated":"2020-09-28T09:06:31.030Z","comments":true,"path":"2020/09/28/004-接口和抽象类/","link":"","permalink":"/2020/09/28/004-接口和抽象类/","excerpt":"","text":"接口和抽象类这个问题，要分JDK版本来区分回答： JDK1.8之前： 语法： 抽象类：方法可以有抽象的，也可以有非抽象, 有构造器 接口：方法都是抽象，属性都是常量，默认有public static final修饰（接口实际上就是一种契约） 设计： 抽象类：同一类事物的抽取，比如针对Dao层操作的封装，如，BaseDao，BaseServiceImpl 接口：通常更像是一种标准的制定，定制系统之间对接的标准 例子： 1，单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao 2，分布式项目，面向服务的开发，抽取服务service，这个时候，就会产生服务的提供者和服务的消费者两个角色 这两个角色之间的纽带，依然是接口 JDK1.8之后： 接口里面可以有实现的方法，注意要在方法的声明上加上default或者static 最后区分几个概念： 多继承，多重继承，多实现 多重继承：A-&gt;B-&gt;C（爷孙三代的关系） 多实现：Person implements IRunable,IEatable（符合多项国际化标准） 多继承：接口可以多继承，类只支持单继承 面向接口编程的好处：解耦。比如分层开发的时候，上一层调用下一层，为了解耦，不要调具体的实现，要使用接口将二者连接起来，那么上层和下层就解耦了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"003.String_StringBuffer_String_Builder的区别","slug":"003-String-StringBuffer-String-Builder的区别","date":"2020-09-28T08:59:27.000Z","updated":"2020-09-28T09:03:54.472Z","comments":true,"path":"2020/09/28/003-String-StringBuffer-String-Builder的区别/","link":"","permalink":"/2020/09/28/003-String-StringBuffer-String-Builder的区别/","excerpt":"","text":"String 跟其他两个类的区别是 String是final类型，每次声明的都是不可变的对象，所以每次操作都会产生新的String对象，然后将指针指向新的String对象。 StringBuffer，StringBuilder都是在原有对象上进行操作 所以，如果需要经常改变字符串内容，则建议采用这两者。 StringBuffer vs StringBuilder 前者是线程安全的，后者是线程不安全的。线程不安全性能更高，所以在开发中，优先采用StringBuilder.StringBuilder &gt; StringBuffer &gt; String（性能比较） StringBuffer中每个方法都加了synchronized修饰关于选用哪个类的场景“不考虑安全的情况，选用StringBuilder；不考虑安全的情况，选用StringBuffer。”的说法是错误的！！！ 因为当多线程情况下才需要考虑这些，单线程是不需要考虑的。直接上性能！ 开发中，用StringBuider来解决什么问题？字符拼接： ​ 在方法内使用：StringBuilder.append(“”);","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Redis回顾（数据类型及使用场景）","slug":"Redis回顾（数据类型及使用场景）","date":"2020-09-28T08:59:27.000Z","updated":"2020-11-12T15:22:07.564Z","comments":true,"path":"2020/09/28/Redis回顾（数据类型及使用场景）/","link":"","permalink":"/2020/09/28/Redis回顾（数据类型及使用场景）/","excerpt":"","text":"一、redis基本基本介绍1、 redis解决分布式环境下缓存不同步让缓存集中处理(大家使用同一个缓存服务),我们需要一个类似于MYSQL这样可以通过服务来提供第三方的缓存工具(缓存服务器);流行的第三方缓存服务器:memcache/redis2、REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统(可以把redis想象成一个巨大的MAP)。Redis和ehcache不一样的是，ehcache可以看做一个嵌入式的缓存框架，而redis是一个独立的应用服务（像MYSQL一样），既可以提供缓存功能，还可以把数据持久化到磁盘上(redis也可以提供持久化的功能,在某些情况下,redis也可以作为数据库存在)；3、性能极高 – Redis能支持超过 10W次每秒的读写频率。丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行(简单的事务)。丰富的特性 – Redis还支持 publish/subscribe(发布/订阅), 通知, key 过期等等特性。 二、redis基本命令和存储redis命令分为： 对数据的操作； 发布/订阅相关操作； 事务控制； 脚本命令； 连接服务器命令； 数据库服务相关命令；redis存储：1，redis可以作为内存数据库，也可以把数据持久化到磁盘上；大部分情况下,都是把redis作为内存数据库;2，默认情况下 #after 900 sec (15 min) if at least 1 key changed #after 300 sec (5 min) if at least 10 keys changed #after 60 sec if at least 10000 keys changed在redis配置文件中： save 900 1 save 300 10 save 60 100003，数据默认存储在安装目录下.rdb文件中（可以在配置文件中dbfilename dump.rdb配置）；4，redis也可以设置为append模式，每次key的修改都会append到文件中，这种方式有可能丢失60秒的数据； 通过配置：appendonly yes开启 appendfilename “appendonly.aof”设置append文件； 可以设置append的模式（类似于mysql的事务文件同步机制）： # appendfsync always：每次更新key及时同步到append文件； # appendfsync everysec：每一秒同步一次key的更新； # appendfsync no：不管理append文件的更新，根据操作系统去定 三、redis中String数据类型 http://redis.cn/commands.html#string1、常见的字符串操作： strlen key：返回key的value的值长度； getrange key X Y：返回key对应value的一个子字符串，位置从X到Y； append key value：给key对应的value追加值，如果key不存在，相当于set一个新的值；2、如果字符串的内容是数值（integer，在redis中，数值也是string） incr key：在给定key的value上增加1；（常用于id）；redis中的incr是一个原子操作，支持并发；如果key不存在，则相当于设置1； incrby key value：给定key的value上增加value值；相当于key=key.value+value；这也是一个原子操作； decr：在给定key的value上减少1； decrby key value：给定key的value上减少value值；3、string最常见的使用场景：存储json类型对象 incr user:id set user:1 {id:1,name:xiaolong} 第一个user设置属性 incr user:id incr 是原子操作，支持并发 set user:2 {id:2,name:stef} 第二个user设置属性作为计数器, incr count;优酷视频点赞（为第100个视频点赞统计） 初 始 set vedio：100：goodcount 0 点 赞 incr vedio：100：good：count 取消点赞 decr vedio：100：good：count 四、redis中的List http://redis.cn/commands.html#list1、redis的LIST结构(想象成java中的List)，是一个双向链表结构，可以用来存储一组数据；从这个列表的前端和后端取数据效率非常高；2、list的常用操作： RPUSH：在一个list最后添加一个元素RPUSH firends “stef” LPUSH：在一个list最前面添加一个元素LPUSH firends “stea” LTRIM key start stop：剪裁一个列表，剩下的内容从start到stop；LTRIM friends 0,3 =&gt;只剩下前4个数据； LRANGE key start stop：获取列表中的一部分数据，两个参数，第一个参数代表第一个获取元素的位置（0）开始，第二个值代表截止的元素位置，如果第二个参数为-1，截止到列表尾部==&gt;LRANGE firends 0 -1 LLEN key： 返回一个列表当前长度==&gt;LLEND friends LPOP：移除list中第一个元素，并返回这个元素==&gt;LPOP friends RPOP：移除list中最后一个元素，并返回这个元素==&gt;RPOP friends3,使用场景:①可以使用redis的list模拟队列,堆栈②朋友圈点赞； 规定:朋友圈内容的格式: 内容: user❌post:x content来存储; 点赞: post❌good list来存储; 创建一条微博内容：set user:1:post:91 ‘hello redis’; 点赞： lpush post:91:good ‘{id:1,name:stef,img:xxx.jpg}’ lpush post:91:good ‘{id:2,name:xl,img:xxx.jpg}’ lpush post:91:good ‘{id:3,name:xm,img:xxx.jpg}’③查看有多少人点赞: llen post:91:good④查看哪些人点赞：lrange post:91:good 0 -1思考，如果用数据库实现这个功能，SQL会多复杂？？ 示例2：回帖 ①创建一个帖子： set user:1:post:90 ‘wohenshuai’ ②创建一个回帖： set postreply:1 ‘nonono’ ③把回帖和帖子关联： lpush post:90:replies 1 ④再来一条回帖： set postreply:2 ‘hehe’ lpush post:90:replies 2 ⑤查询帖子的回帖： lrange post:90:replies 0 -1 get postreply:2 五、redis中的Set http://redis.cn/commands.html#set1、SET结构和java中差不多，数据没有顺序，并且每一个值不能重复；2、SET结构的常见操作： SADD：给set添加一个元素==&gt;SADD language ‘java’ SREM：从set中移除一个给定元素==&gt;SREM language ‘php’ SISMEMBER：判断给定的一个元素是否在set中，如果存在，返回1，如果不存在，返回0==&gt;sismember language ‘php’ SMEMBERS：返回指定set内所有的元素，以一个list形式返回==&gt;smembers language SCARD：返回set的元素个数==&gt;scard language SRANDMEMBER key count:返回指定set中随机的count个元素==&gt; srandmember friends 3 //随机推荐3个用户（典型场景，抽奖） SUNION(并集)：综合多个set的内容，并返回一个list的列表，包含综合后的所有元素; sadd language ‘php’ sadd pg ‘c’ sadd pg ‘c++’ sadd pgs ‘java’ sadd pgs ‘swift’ sunion language pg pgs SINTER key [key …] (交集)：获取多个key对应的set之间的交集SINTER friends:user:1000 friends:user:1001 friends:user:1002 =&gt;获取1000,1001,1002三个用户的共同好友列表； SINTERSTORE destination key [key …] ：获取多个key对应的set之间的交集，并保存为新的key值；目标也是一个set；SINTER groupfriends friends:user:1000 friends:user:1001 friends:user:1002 =&gt;获取三个用户共同的好友列表并保存为组好友列表；3、set的使用场景：①、去重；②、抽奖; 准备一个抽奖池:sadd luckdraws 1 2 3 4 5 6 7 8 9 10 11 12 13 抽3个三等奖:srandmember luckdraws 3srem luckdraws 11 1 10 抽2个二等奖:三、做set运算（好友推荐） 初始化好友圈 sadd user:1:friends ‘user:2’ ‘user:3’ ‘user:5’ sadd user:2:friends ‘user:1’ ‘user:3’ ‘user:6’ sadd user:3:friends ‘user:1’ ‘user:7’ ‘user:8’ 把user:1的好友的好友集合做并集; user:1 user:3 user:6 user:7 user:8 让这个并集和user:1的好友集合做差集; user:1 user:6 user:7 user:8 从差集中去掉自己 user:6 user:7 user:8 随机选取推荐好友 六、redis中的Sort Set http://redis.cn/commands.html#sorted_set1、SET是一种非常方便的结构，但是数据无序，redis提供了一个sorted set，每一个添加的值都有一个对应的分数，可以通过这个分数进行排序;sorted set中的排名是按照分组升序排列2、Sortedset的常用操作： ZADD：添加一个带分数的元素，也可以同时添加多个： ZADD hackers 1940 “Alan Kay” ZADD hackers 1906 “Grace Hopper” ZADD hackers 1969 “Linus Torvalds” ZADD hackers 1940 “Alan Kay” 1906 “Grace Hopper” 1969 “Linus Torvalds” ZCOUNT key min max ：给定范围分数的元素个数： ZCOUNT hackers 1940 1960 =&gt;1940到1960的hacker个数； ZRANK key member ：查询指定元素的分数在整个列表中的排名（从0开始） ZRANK hackers “Alan Kay” =&gt;alan kay的年龄在所有hacker中的排名； zrange hackers 0 -1 =&gt; 1) “Grace Hopper” 2) “Alan Kay” 3) “Linus Torvalds” ZREVRANGE key start stop：按照分数从小到大排;3、sorted set的使用场景：sorted set算是redis中最有用的一种结构，非常适合用于做海量的数据的排行（比如一个巨型游戏的用户排名）；sorted set中所有的方法都建议大去看一下；sorted set的速度非常快；示例1，天梯排名： 1，添加初始排名和分数： 2，查询fat在当前ladder中的排名： 3，查询ladder中的前3名： 4，jian增加了20ladder score： 示例2： LRU淘汰最长时间没使用； LFU淘汰最低使用频率； 七、redis中的hash http://redis.cn/commands.html#hash1、hashes可以理解为一个map，这个map由一对一对的字段和值组成，所以，可以用hashes来保存一个对象：2、hashes的常见操作： HSET:给一个hashes添加一个field和value； HSET user:1000 name “John Smith” HSET user:1000 email “john.smith@example.com“ HSET user:1000 password “s3cret” HGET可以得到一个hashes中的某一个属性的值： HGET user:1000 name =&gt;“John Smith” HGETALL：一次性取出一个hashes中所有的field和value，使用list输出，一个field，一个value有序输出； HGETALL user:1000 =&gt; 1) “name” 2) “John Smith” 3) “email” 4) “john.smith@example.com“ 5) “password” 6) “s3cret” HMSET:一次性的设置多个值(hashes multiple set) HMSET user:1001 name “Mary Jones” password “hidden” email “mjones@example.com“ HMGET：一次性的得到多个字段值(hashes multiple get)，以列表形式返回； HMGET user:1001 name email =&gt; 1)“Mary Jones” 2)“mjones@example.com” HINCRBY：给hashes的一个field的value增加一个值(integer)，这个增加操作是原子操作： HSET user:1000 visits 10 HINCRBY user:1000 visits 1 =&gt; 11 HINCRBY user:1000 visits 10 =&gt; 21 HKEYS：得到一个key的所有fields字段，以list返回： HKEYS user:1000 =&gt; 1)“name” 2)“password” 3)“email” HDEL:删除hashes一个指定的filed； HDEL user:1000 visits3、使用场景: 使用hash来保存一个对象更直观;(建议不使用hash来保存) 分组 set user:id 1 set dept:id 1 HMSET ids user:id 1 dept:id 1 orderbill:id 1 HINCRBY ids user:id HINCRBY ids dept:id HMSET users user:1 “{id:1,name:xx}” user:2 “{id:2,name:xx}”","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"002.final的用法及相关注意点","slug":"002-final的用法及相关注意点","date":"2020-09-28T03:46:49.000Z","updated":"2020-09-28T09:02:32.058Z","comments":true,"path":"2020/09/28/002-final的用法及相关注意点/","link":"","permalink":"/2020/09/28/002-final的用法及相关注意点/","excerpt":"","text":"final修饰类，表示类不可变，不可继承 比如，String，不可变性 final修饰方法，表示该方法不可重写 比如模板方法，可以固定我们的算法 final修饰变量，这个变量就是常量 注意： 修饰的是基本数据类型，这个值本身不能修改 修饰的是引用类型，引用的指向不能修改 比如下面的代码是可以的 final Student student = new Student(1,&quot;Andy&quot;); student.setAge(18);//注意，这个是可以的！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"001.“==” 与 equals的区别","slug":"001-==和equals的区别","date":"2020-09-28T03:00:00.000Z","updated":"2020-09-28T09:02:12.703Z","comments":true,"path":"2020/09/28/001-==和equals的区别/","link":"","permalink":"/2020/09/28/001-==和equals的区别/","excerpt":"","text":"“==” 与 equals的区别 == 比较的是值比较基本的数据类型，比较的是数值 比较引用类型：比较引用指向的值（地址） equals默认比较也是地址，因为这个方法的最初定义在Object上，默认的实现就是比较地址 自定义的类，如果需要比较的是内容，那么就要学String，重写equals方法 代码案例：测试以下的每道题，你是否能够正确得到答案？ String s = “java”; String s = new String(“java”); 这两者的内存分配方式是不一样的。 第一种方式，JVM会将其分配到常量池，而第二种方式是分配到堆内存 /** * 测试 == 和 eauals */ @Test public void test01(){ String s1 = new String(&quot;zs&quot;); String s2 = new String(&quot;zs&quot;); System.out.println(s1 == s2); // false String s3 = &quot;zs&quot;; // 指向常量池地址 String s4 = &quot;zs&quot;; System.out.println(s3 == s4); // true System.out.println(s3 == s1); // false String s5 = &quot;zszs&quot;; String s6 = s3+s4; System.out.println(s5 == s6); // false ：字符串是个不可变对象，相加时需要创建新对象（相当于new了一下） 用反编译工具验证 final String s7 = &quot;zs&quot;; // final修饰的不再是变量，是常量 final String s8 = &quot;zs&quot;; String s9 = s7+s8; // 编译器在处理常量运算的时候，会进行优化，将二者之和再转变为常量 System.out.println(s5 == s9); // true final String s10 = s3+s4; // 右边依然是变量，所以创建的时候还是要new，而final是影响的s10，而不会影响s3+s4的特性 System.out.println(s5 == s10); // false }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"写发文章步骤.md","slug":"Hexo写发文章步骤","date":"2020-09-28T02:22:01.000Z","updated":"2020-10-02T06:34:58.103Z","comments":true,"path":"2020/09/28/Hexo写发文章步骤/","link":"","permalink":"/2020/09/28/Hexo写发文章步骤/","excerpt":"","text":"1、编辑 2、本地预览在博客文件夹右键Bash，输入（hexo generate） hexo g 生成之后，再输入（hexo server的简写） hexo s 来启动博客，通过给定的地址进行本地预览。 2、发布 发布到github Ctrl+C停止本地预览。 输入(hexo deploy) hexo d 将改动后的博客部署到github上。在网络畅通的情况下，很快可以刷新出更新后的博客。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Hexo写文章","slug":"Hexo写文章","permalink":"/tags/Hexo写文章/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}